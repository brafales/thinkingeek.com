<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Forgotten memories (1)</title>
  <meta name="description" content="Most compiler infrastructures that target register machines do it by using the concept of virtual registers. In their intermediate representations instructions use virtual registers to represent their operands. Because hardware is finite, these virtual registers must be mapped to physical registers at some point. The compiler does this in a process called register allocation. Being physical registers finite, it may happen that not all the virtual registers used by the program can be held in physical registers at the same time. When this happens, the compiler must emit spill code. Spill code stores a value in a memory (spill) and loads it later, often close to the point of use (reload). The memory used for spill code is commonly the function stack. However nothing prevents us from using other kinds of “memories” as long as we can guarantee that nobody is going to use them. This is exactly the kind of experiment we will do today: we’re going to spill general-purpose registers into floating-point registers.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://thinkingeek.com/2020/06/20/forgotten-memories-1/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Think In Geek" href="https://thinkingeek.com/feed.xml">

  

  
  <meta property="og:title" content="Forgotten memories (1)">
  <meta property="og:site_name" content="Think In Geek">
  <meta property="og:url" content="https://thinkingeek.com/2020/06/20/forgotten-memories-1/">
  <meta property="og:description" content="Most compiler infrastructures that target register machines do it by using the concept of virtual registers. In their intermediate representations instructions use virtual registers to represent their operands. Because hardware is finite, these virtual registers must be mapped to physical registers at some point. The compiler does this in a process called register allocation. Being physical registers finite, it may happen that not all the virtual registers used by the program can be held in physical registers at the same time. When this happens, the compiler must emit spill code. Spill code stores a value in a memory (spill) and loads it later, often close to the point of use (reload). The memory used for spill code is commonly the function stack. However nothing prevents us from using other kinds of “memories” as long as we can guarantee that nobody is going to use them. This is exactly the kind of experiment we will do today: we’re going to spill general-purpose registers into floating-point registers.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Forgotten memories (1)">
  <meta name="twitter:description" content="Most compiler infrastructures that target register machines do it by using the concept of virtual registers. In their intermediate representations instructions use virtual registers to represent th...">
  
  

  <link rel="stylesheet" href="/assets/fonts/fonts.css">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

      <span class="site-title"><a href="/">Think In Geek</a> | </span>
      <span class="site-slogan">In geek we trust</span>

    <nav class="site-nav"><a class="page-link" href="/series/">Series</a><a class="page-link" href="/author/brafales/">Posts by Bernat Ràfales</a><a class="page-link" href="/archives/">Archives</a></nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Forgotten memories (1)</h1>
    
    <p class="post-meta"><time datetime="2020-06-20T18:00:00+00:00" itemprop="datePublished">Jun 20, 2020</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">compilers</a>, <a href="/categories/llvm/">llvm</a>, <a href="/categories/risc-v/">risc-v</a></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Most compiler infrastructures that target register machines do it by using the
concept of <em>virtual registers</em>. In their intermediate representations instructions
use virtual registers to represent their operands.</p>

<p>Because hardware is finite, these virtual registers must be mapped to physical
registers at some point. The compiler does this in a process called <a href="https://en.wikipedia.org/wiki/Register_allocation"><em>register
allocation</em></a>.</p>

<p>Being physical registers finite, it may happen that not all the virtual
registers used by the program can be held in physical registers at the same
time. When this happens, the compiler must emit <em>spill code</em>. Spill code stores
a value in a memory (<em>spill</em>) and loads it later, often close to the point of
use (<em>reload</em>).</p>

<p>The memory used for spill code is commonly the <em>function stack</em>. However
nothing prevents us from using other kinds of “memories” as long as we can
guarantee that nobody is going to use them. This is exactly the kind of
experiment we will do today: we’re going to spill general-purpose registers
into floating-point registers.</p>

<!--more-->

<h1>Some context first</h1>

<p>Today’s experiment will be done using RISC-V and LLVM.</p>

<h2>RISC-V</h2>

<p><a href="https://www.riscv.org">RISC-V</a> is an open-source, RISC-style, ISA maintained
by the RISC-V Foundation. One of its features is that it is very modular so the
ISA has a number of standard extensions including those that provide floating
point instructions and registers.</p>

<p>The base RISC-V ISA defines 32 integer registers. They are 32-bit in 32-bit
versions of RISC-V and 64-bit in 64-bit versions of RISC-V. We will call them
general-purpose (GPR) even if they can only operate integers or addresses. The
F standard extension adds 32 floating point registers (FPR) of 32-bit. The D
standard extension extends those registers to be 64-bit. This way, the F
extension provides support for <a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">IEEE 754
Binary32</a>
and the D extension provides support for <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 754
Binary64</a>.</p>

<h2>LLVM</h2>

<p><a href="https://www.llvm.org">LLVM</a> is an umbrella project for compilers and other
related tools hosted by the LLVM Foundation. LLVM has a backend for RISC-V
that is still pretty hackable for experiments.</p>

<h2>Related work</h2>

<p>This is not a new idea, of course. The paper <a href="https://dl.acm.org/doi/abs/10.1145/1375527.1375574">Exploiting idle register classes
for fast spill destination</a>
explored it already. The reported results seem promising (ranging from 1.7% to
10%) but are ultimately predicated to being able to do moves between different
register banks with reasonable latency. This is not always the case in all
architectures. However that paper is from 2008 so some of the results may need
to be reevaluated with current architectures.</p>

<h1>Spill code in LLVM</h1>

<p>This is not obvious, but there are at least two reasons why we may need to
spill (i.e.  store) and reload (i.e. load) the value of a register. The first
one we already saw it: register allocation.</p>

<p>However, there is a second reason: callee-saved registers. <a href="https://en.wikipedia.org/wiki/Application_binary_interface">Application Binary
Interfaces</a> specify
how functions can use registers. One of the things they specify is whether the
contents of a register is preserved across function calls or not. If the value
held in a register is preserved across function calls then either who does the
call (the caller) or who is called (the callee) are responsible for preserving
it. Thus a register is either <em>caller-save</em> or <em>callee-save</em>, respectively.</p>

<p>A way to simplify a bit all this is to assume that if a register is <strong>not</strong>
callee-save then it is likely (though not necessarily) to be caller-save, which
means it is up to the caller to preserve the value of the register across a
function call, in case the value needs to be preserved.</p>

<p>These two kind of spill code are emitted in two different moments in the
compilation pipeline of LLVM. Register allocation is executed earlier. Later
on, a process called Prologue / Epilogue Emitter is the responsible of emitting
the spills for the callee-saved registers.</p>

<h1>Current status</h1>

<p>Consider the following C code. This is the accumulating part of a naive 64x64
integer matrix multiplication. Nothing special in it other than we request
clang to unroll it 16 times. Unrolling is used here as an easy way to increase
<em>register pressure</em> (the number of register needed at the same time) so we
force the compiler to spill values. Even in an architecture whith a large
number of registers like RISC-V, spilling (caused by register allocation) may
be unavoidable.</p>

<figure class="highlight"><figcaption>example.c</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">enum</span> <span class="p">{</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">64</span> <span class="p">};</span>

<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="cp">#pragma clang loop unroll_count(16)
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>I’m going to use <code class="language-plaintext highlighter-rouge">riscv64-unknown-linux-gnu</code> as a handy example here of a
RISC-V 64-bit architecture that has both F and D extensions. We can generate
the assembly output like this.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>clang <span class="nt">--target</span><span class="o">=</span>riscv64-unknown-linux-gnu <span class="nt">-S</span> <span class="nt">-O2</span> <span class="nt">-o</span> example.s example.c</code></pre></figure>

<p>To store a GPR to a memory location in RISC-V 64-bit we use the <code class="language-plaintext highlighter-rouge">sd</code>
instruction. Stack locations in this function are easy to spot because they are
addresses based on the <code class="language-plaintext highlighter-rouge">sp</code> (stack pointer) register.</p>

<p>If we examine the assembly listing for this function, we first see a bunch of
stores to the stack. Those are the spills caused by the callee-saved registers.</p>

<figure class="highlight"><figcaption>example.s</figcaption><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>f:                                      # @f
        addi    sp, sp, -256    # Grow the stack
        sd      ra, 248(sp)
        sd      s0, 240(sp)
        sd      s1, 232(sp)
        sd      s2, 224(sp)
        sd      s3, 216(sp)
        sd      s4, 208(sp)
        sd      s5, 200(sp)
        sd      s6, 192(sp)
        sd      s7, 184(sp)
        sd      s8, 176(sp)
        sd      s9, 168(sp)
        sd      s10, 160(sp)
        sd      s11, 152(sp)
        sd      a2, 128(sp)
        sd      zero, 136(sp)
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is followed by a bunch of values that compute addresses for the <code class="language-plaintext highlighter-rouge">b</code> matrix
that are also spilled. Note that the spill here is just the <code class="language-plaintext highlighter-rouge">sd</code> instruction. The
<code class="language-plaintext highlighter-rouge">addi</code> was part of the original program.</p>

<figure class="highlight"><figcaption>example.s</figcaption><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>        sd      a2, 128(sp)
        sd      zero, 136(sp)
        addi    a2, a1, 4
        sd      a2, 112(sp)
        addi    a2, a1, 8
        sd      a2, 104(sp)
        addi    a2, a1, 12
        sd      a2, 96(sp)
        addi    a2, a1, 16
        sd      a2, 88(sp)
        addi    a2, a1, 20
        sd      a2, 80(sp)
        addi    a2, a1, 24
        sd      a2, 72(sp)
        addi    a2, a1, 28
        sd      a2, 64(sp)
        addi    a2, a1, 32
        sd      a2, 56(sp)
        addi    a2, a1, 36
        sd      a2, 48(sp)
        addi    a2, a1, 40
        sd      a2, 40(sp)
        addi    a2, a1, 44
        sd      a2, 32(sp)
        addi    a2, a1, 48
        sd      a2, 24(sp)
        addi    a2, a1, 52
        sd      a2, 16(sp)
        addi    a2, a1, 56
        sd      a2, 8(sp)
        sd      a1, 120(sp)
        addi    a1, a1, 60
        sd      a1, 0(sp)
</pre></td></tr></tbody></table></code></pre></figure>

<p>To load a GPR from a memory location in RISC-V 64-bit we use the <code class="language-plaintext highlighter-rouge">ld</code>
instruction.</p>

<p>When the outermost loop of the matrix multiplication starts, it reloads a bunch
of things that we just spilled. If this seems pointless to you, note that this
is a loop so it is going to be pointless only in the first iteration (i.e.
these registers will be reused in the loop so we need to reload their value).
The <code class="language-plaintext highlighter-rouge">ld</code> instruction is used to load a GPR from a memory location.</p>

<figure class="highlight"><figcaption>example.s</figcaption><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="code"><pre>        mv      s10, zero
        ld      a4, 0(sp)
        ld      s11, 8(sp)
        ld      ra, 16(sp)
        ld      s6, 24(sp)
        ld      s7, 32(sp)
        ld      s2, 40(sp)
        ld      t6, 48(sp)
        ld      t5, 56(sp)
        ld      t4, 64(sp)
        ld      t3, 72(sp)
        ld      t2, 80(sp)
        ld      t1, 88(sp)
        ld      t0, 96(sp)
        ld      a7, 104(sp)
        ld      a6, 112(sp)
        ld      s8, 120(sp)
</pre></td></tr></tbody></table></code></pre></figure>

<p>If we go to the end of the function, we see the reloads of the callee-saved
registers, right before returning.</p>

<figure class="highlight"><figcaption>example.s</figcaption><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
</pre></td><td class="code"><pre>        ld      s11, 152(sp)
        ld      s10, 160(sp)
        ld      s9, 168(sp)
        ld      s8, 176(sp)
        ld      s7, 184(sp)
        ld      s6, 192(sp)
        ld      s5, 200(sp)
        ld      s4, 208(sp)
        ld      s3, 216(sp)
        ld      s2, 224(sp)
        ld      s1, 232(sp)
        ld      s0, 240(sp)
        ld      ra, 248(sp)
        addi    sp, sp, 256
        ret
</pre></td></tr></tbody></table></code></pre></figure>

<h1>What do we want to do?</h1>

<p>The F and D extensions provide us with 32 floating point registers. However for
leaf functions (functions that do not call other functions) like this one,
which need to spill a bunch of GPRs, it could be beneficial to be able to spill
those values onto those floating point registers, if possible.</p>

<div style="padding: 1em; background-color: #fee;">
Why are we restricting ourselves to leaf functions? We don't have, but in this
post we're using a very naive approach that cannot support more advanced use
cases. In a more advance model we would link a spill with all of its reloads.
It may happen that the program never crosses a function call from the spill to
any of its reloads. In this case we could allow functions having function
calls. Also this advanced model might allow us to be more precise when
gathering the available floating point registers (it might happen a FPR is used
in the function but not in the part involving a spill and all its reloads).
</div>

<h2>Strategy</h2>

<p>As I mentioned I’m going to use an extremely simplistic approach here. More
complex approaches are possible but are going to require more infrastructure.
We are not doing that today.</p>

<p>After “Prologue Epilogue Emitter” has spilled all the callee-saved registers it
invokes a target-specific <em>hook</em>. We will run some extra code in that hook.</p>

<ol>
  <li>Check if this function is a leaf, otherwise bail out.</li>
  <li>Check if we’re compiling with F (for RISC-V 32-bit) or D (for RISC-V 64-bit). If this is not the case, bail out.</li>
  <li>Determine all the used registers by the function. From that information compute how many of FPRs are available. If none is available, bail out.</li>
  <li>Now for each instruction that is a store/load to/from the stack, this is a spill/reload, find a FPR for it. If one is still available, map the frame index (I explain later what a frame index is) to the FPR, emit the proper move from/to GPR to/from FPR for the spill/reload and mark the frame index as dead. Otherwise just ignore this frame index. FPRs are assigned as we find spill/reloads instructions in the function.</li>
</ol>

<h1>Implementation</h1>

<p>I will call this process “soften spills”: we are still <em>morally</em> spilling but
because we are not hitting the memory system it could be a cheaper operation.
I’m sure better names exist but I went with this one.</p>

<h2>Entry point</h2>

<p>The target specific that “Prologue/Epilogue Emitter” right after it has emitted
the spills and reloads of callee-saved registers is called
<code class="language-plaintext highlighter-rouge">processFunctionBeforeFrameFinalized</code>. For the RISC-V backend this function is
in <code class="language-plaintext highlighter-rouge">llvm/lib/Target/RISCV/RISCVFrameLowering.cpp</code>. To keep things a bit tidy I
added the call here but I implemented the algorithm in another file.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVFrameLowering.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="n">RISCVFrameLowering</span><span class="o">::</span><span class="n">processFunctionBeforeFrameFinalized</span><span class="p">(</span>
    <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">RegInfo</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getSubtarget</span><span class="p">().</span><span class="n">getRegisterInfo</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">RISCV</span><span class="o">::</span><span class="n">GPRRegClass</span><span class="p">;</span>
  <span class="c1">// estimateStackSize has been observed to under-estimate the final stack</span>
  <span class="c1">// size, so give ourselves wiggle-room by checking for stack size</span>
  <span class="c1">// representable an 11-bit signed field rather than 12-bits.</span>
  <span class="c1">// FIXME: It may be possible to craft a function with a small stack that</span>
  <span class="c1">// still needs an emergency spill slot for branch relaxation. This case</span>
  <span class="c1">// would currently be missed.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">11</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MFI</span><span class="p">.</span><span class="n">estimateStackSize</span><span class="p">(</span><span class="n">MF</span><span class="p">)))</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">RegScavFI</span> <span class="o">=</span> <span class="n">MFI</span><span class="p">.</span><span class="n">CreateStackObject</span><span class="p">(</span>
        <span class="n">RegInfo</span><span class="o">-&gt;</span><span class="n">getSpillSize</span><span class="p">(</span><span class="o">*</span><span class="n">RC</span><span class="p">),</span> <span class="n">RegInfo</span><span class="o">-&gt;</span><span class="n">getSpillAlignment</span><span class="p">(</span><span class="o">*</span><span class="n">RC</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">RS</span><span class="o">-&gt;</span><span class="n">addScavengingFrameIndex</span><span class="p">(</span><span class="n">RegScavFI</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// If we want to soften spills, we do it now.</span>
  <span class="n">RISCVSoftenXSpillsReload</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MF</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This is a convenient place to do the spill softening because here we will be able to
see the spills and reloads emitted by the register allocator and also the
spills and reloads emitted by “Prologue/Epilog Emitter”. Earlier than that we
would be missing the latter kind of spills and reloads. And later than that,
the stack layout of the function would have already been generated so while we
could remove the spills, the storage for them would have already been
accounted. In fact we will see later that changing the frame information here
is kind of unexpected and we will have to amend a few bits.</p>

<h2>Prolegomena</h2>

<p>I implemented this in another file so we will need some boilerplate before we
can continue.</p>

<p>Following is the main implementation file.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="c1">//===----- RISCVSoftenSpills.cpp - Soften Spills using FPR registers ------===//</span>
<span class="c1">//</span>
<span class="c1">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span>
<span class="c1">// See https://llvm.org/LICENSE.txt for license information.</span>
<span class="c1">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include</span> <span class="cpf">"RISCV.h"</span><span class="cp">
#include</span> <span class="cpf">"RISCVTargetMachine.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/Support/Debug.h"</span><span class="cp">
#include</span> <span class="cpf">"llvm/ADT/DenseMap.h"</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="cp">#define DEBUG_TYPE "riscv-soften-spills"
</span>
<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">EnableSoftenSpills</span><span class="p">(</span>
    <span class="s">"riscv-soften-spills"</span><span class="p">,</span>
    <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">"Enable softening spills using FPR registers when available"</span><span class="p">),</span>
    <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">llvm</span><span class="o">::</span><span class="n">RISCVSoftenXSpillsReload</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EnableSoftenSpills</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// .. rest of the code here ...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>I added a <a href="https://llvm.org/docs/CommandLine.html">command line option</a>, so we
can manually enable the softening from clang using <code class="language-plaintext highlighter-rouge">-mllvm
-riscv-soften-spills</code>. The macro <code class="language-plaintext highlighter-rouge">DEBUG_TYPE</code> is needed when we later on use
<code class="language-plaintext highlighter-rouge">LLVM_DEBUG</code>, this is used to filter debug messages via <code class="language-plaintext highlighter-rouge">-mllvm
-debug-only=riscv-soften-spills</code>.</p>

<p>This function will return <code class="language-plaintext highlighter-rouge">true</code> if it changed something, otherwise it will
return <code class="language-plaintext highlighter-rouge">false</code>. We do not use this value but a caller might be interested to
know if we actually changed something.</p>

<p>This function is defined in the <code class="language-plaintext highlighter-rouge">llvm</code> namespace for simplicity. So we need a
declaration in that namespace first. We can add one in <code class="language-plaintext highlighter-rouge">RISCV.h</code>. <strong>Note:</strong>
There are better ways to organise this code, this one is just simple and
effective.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCV.h</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">50
51
52
53
</pre></td><td class="code"><pre><span class="c1">// FIXME - Move this to a better place.</span>
<span class="kt">bool</span> <span class="nf">RISCVSoftenXSpillsReload</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span><span class="p">);</span>

<span class="p">}</span> <span class="c1">// namespace llvm</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Also we need to let know cmake about this new file.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/CMakeLists.txt</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="n">add_llvm_target</span><span class="p">(</span><span class="n">RISCVCodeGen</span>
  <span class="n">RISCVAsmPrinter</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVCallLowering</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVExpandPseudoInsts</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVFrameLowering</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVInstrInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVInstructionSelector</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVISelDAGToDAG</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVISelLowering</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVLegalizerInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVMCInstLower</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVMergeBaseOffset</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVRegisterBankInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVRegisterInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVSubtarget</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVTargetMachine</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVTargetObjectFile</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">RISCVTargetTransformInfo</span><span class="p">.</span><span class="n">cpp</span>

  <span class="n">RISCVSoftenSpills</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2>Early bail-outs</h2>

<p>Before we continue we need to gather some information. We are passing the
<code class="language-plaintext highlighter-rouge">MachineFunction</code> which is the object that represents the whole function in the
code generation phase of LLVM. We get two kinds of objects, those that are
<code class="language-plaintext highlighter-rouge">Machine</code><em>Something</em> concern to the current function being compiled. Those that
are <code class="language-plaintext highlighter-rouge">Target</code><em>Something</em> are backend-specific information not necessarily
function-specific (i.e. they might be shared between functions).</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>  <span class="c1">// Gather some information that we will need.</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">MachineRegisterInfo</span> <span class="o">*</span><span class="n">MRI</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getRegInfo</span><span class="p">();</span>

  <span class="k">const</span> <span class="n">RISCVSubtarget</span> <span class="o">*</span><span class="n">Subtarget</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">RISCVSubtarget</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">RISCVInstrInfo</span> <span class="o">*</span><span class="n">TII</span> <span class="o">=</span>
      <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">RISCVInstrInfo</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">getInstrInfo</span><span class="p">());</span>
  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span> <span class="o">=</span> <span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">getRegisterInfo</span><span class="p">();</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">MachineFrameInfo</code> (<code class="language-plaintext highlighter-rouge">MFI</code>) object concerns about objects in the stack for the
current function. LLVM uses a stack abstraction called the <em>frame indexes</em>.
Each frame index is an integer for which we can associate information (like
size and alignment). Those indexes are later on used to compute the size of the
elements required.</p>

<p>The <code class="language-plaintext highlighter-rouge">MachineRegisterInfo</code> (<code class="language-plaintext highlighter-rouge">MRI</code>) deals about the specific register information
used by the function. This is more useful when the <code class="language-plaintext highlighter-rouge">MachineFunction</code> was in SSA
form before Register Allocation. At this point is useful to know what registers
are callee-saved, something we will want to use later.</p>

<p>The <code class="language-plaintext highlighter-rouge">Subtarget</code> is compilation-specific information for the current function. For
instance it allows us to know if we are compiling with support for the F and D
RISC-V standard extensions or whether we are compiling for 64-bit.</p>

<p>The <code class="language-plaintext highlighter-rouge">TargetInstructionInfo</code> (<code class="language-plaintext highlighter-rouge">TII</code>) gives us access to the instructions of this
target (RISC-V in our case) so we can create new instructions. We will need
this when replacing the spills/reloads with moves.</p>

<p>Finally the <code class="language-plaintext highlighter-rouge">TargetRegisterInfo</code> (<code class="language-plaintext highlighter-rouge">TRI</code>) gives us access to the register of this
target. We will need this to enumerate the FPR registers.</p>

<p>A first check we can do now is see if this function has calls. <code class="language-plaintext highlighter-rouge">MFI</code> knows that.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">35
36
37
38
39
</pre></td><td class="code"><pre>  <span class="c1">// If we have calls, for now do nothing.</span>
  <span class="c1">// There are still opportunities here if the pair spill/reload doesn't cross</span>
  <span class="c1">// function calls but they will require a more sophisticated model.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">hasCalls</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Also if we are not compiling for F or D, we won’t be able to use the instruction
we need, so check this as well.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">42
43
44
45
46
47
48
</pre></td><td class="code"><pre>  <span class="c1">// If we are RV64 but we don't have D, give up.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">is64Bit</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">hasStdExtD</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// If we are RV32 but we don't have F, give up.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">hasStdExtF</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2>Gather all the registers used</h2>

<p>Because we use a very simplistic approach, we want to know, globally for the
whole function, what FPRs are available. For that we will iterate all the
instructions and use the class <code class="language-plaintext highlighter-rouge">LiveRegUnits</code>.</p>

<p>LLVM uses a relatively flexible concept of registers. They can be virtual or
physical. If they are physical their storage may be shared with other
registers.</p>

<p>For instance the RISC-V backend in LLVM models floating point registers of the
F extension as <em>subregisters</em> of the floating point registers of the D
extension. This model is sensible because this is what the spec says: a RISC-V
system with the D extension represents a register of the F extension in the
lowest 32-bits of the floating point register. In that sense a floating point
register such as <code class="language-plaintext highlighter-rouge">f3</code> is modelled in LLVM with two registers: <code class="language-plaintext highlighter-rouge">f3_f</code> and
<code class="language-plaintext highlighter-rouge">f3_d</code>, for F and D extensions respectively. LLVM must know that changing
<code class="language-plaintext highlighter-rouge">f3_f</code> will change <code class="language-plaintext highlighter-rouge">f3_d</code>. This what <em>register units</em> are for.</p>

<p>The class <code class="language-plaintext highlighter-rouge">LiveRegUnits</code> allows us to accumulate the register units used by
instructions. So we iterate for each <a href="https://en.wikipedia.org/wiki/Basic_block">basic block</a>
and then for each instruction.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre>  <span class="c1">// Flow-insensitive analysis in which we identify FPR32/FPR64 that</span>
  <span class="c1">// are not used at all.</span>
  <span class="c1">// There are further opportunities as the static path for a spill and all its</span>
  <span class="c1">// reloads might have free FPR registers. However our model is very simple so</span>
  <span class="c1">// we can't represent these.</span>
  <span class="n">LiveRegUnits</span> <span class="nf">LRU</span><span class="p">(</span><span class="o">*</span><span class="n">TRI</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">MBB</span> <span class="o">:</span> <span class="o">*</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">MI</span> <span class="o">:</span> <span class="n">MBB</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">LRU</span><span class="p">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">MI</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2>Callee-saved are of no interest</h2>

<p>I we use callee-saved FPRs, then we will not have achieved anything. The reason
is that if we modify a callee-saved register we need to preserve it. And if we
need to preserve them we need to spill them. Clearly we need to make sure we
don’t consider callee-saved registers.</p>

<p><code class="language-plaintext highlighter-rouge">MRI</code> can tell us which are the callee-saved registers of the function. So we
make a handy function for that.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">63
64
65
66
67
68
69
</pre></td><td class="code"><pre>  <span class="k">const</span> <span class="n">MCPhysReg</span> <span class="o">*</span><span class="n">CalleeSavedRegs</span> <span class="o">=</span> <span class="n">MRI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedRegs</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">IsCalleeSaved</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">MCPhysReg</span> <span class="n">Reg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCPhysReg</span> <span class="o">*</span><span class="n">R</span> <span class="o">=</span> <span class="n">CalleeSavedRegs</span><span class="p">;</span> <span class="o">*</span><span class="n">R</span><span class="p">;</span> <span class="n">R</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">R</span> <span class="o">==</span> <span class="n">Reg</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now we can filter all the FPRs (both for F, <code class="language-plaintext highlighter-rouge">FPR32</code> and D, <code class="language-plaintext highlighter-rouge">FPR64</code>) registers.
If they are available but they are not callee-saved, they are candidates for
our spills. If no register is available, we just bail out.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">71
72
73
74
75
76
77
</pre></td><td class="code"><pre>  <span class="n">BitVector</span> <span class="nf">RegsAvailableFPR</span><span class="p">(</span><span class="n">TRI</span><span class="o">-&gt;</span><span class="n">getNumRegs</span><span class="p">());</span>
  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">&amp;</span><span class="n">FPRRegClass</span> <span class="o">=</span>
      <span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">is64Bit</span><span class="p">()</span> <span class="o">?</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">FPR64RegClass</span> <span class="o">:</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">FPR32RegClass</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">MCPhysReg</span> <span class="n">PhysReg</span> <span class="o">:</span> <span class="n">FPRRegClass</span><span class="p">.</span><span class="n">getRegisters</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LRU</span><span class="p">.</span><span class="n">available</span><span class="p">(</span><span class="n">PhysReg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IsCalleeSaved</span><span class="p">(</span><span class="n">PhysReg</span><span class="p">))</span>
      <span class="n">RegsAvailableFPR</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">PhysReg</span><span class="p">);</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We use the bitvector <code class="language-plaintext highlighter-rouge">RegsAvailableFPR</code> to represent whether a FPR register is
available or not. Registers are identified by numbers (up to a maximum of
<code class="language-plaintext highlighter-rouge">TRI-&gt;getNumRegs()</code>, which depends on the target). If a register is available,
its related position in the corresponding bitvector will be set.</p>

<h2>Find the spills and reloads</h2>

<p>A spill and a reload are no different to a store and a load. So we need a way
to identify spills and reloads among other general load and store instructions.
Luckily LLVM backends have to implement two functions that precisely answers
this question. These two functions are in <code class="language-plaintext highlighter-rouge">TII</code>, who knows about the
instructions of the target.</p>

<p>Let’s make first a convenient function.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
</pre></td><td class="code"><pre>  <span class="c1">// Helper used to identify spills and reloads.</span>
  <span class="k">auto</span> <span class="n">IsSpillReload</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">Result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">IsSpill</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">MI</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="nl">default:</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">LD</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">LW</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">TII</span><span class="o">-&gt;</span><span class="n">isLoadFromStackSlot</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">FI</span><span class="p">))</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">SD</span><span class="p">:</span>
    <span class="k">case</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">SW</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">TII</span><span class="o">-&gt;</span><span class="n">isStoreToStackSlot</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">FI</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">IsSpill</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">Result</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">IsSpill</span><span class="p">);</span>
  <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Given a <code class="language-plaintext highlighter-rouge">MachineInstruction</code> we check if this is one of the spills and reloads
we care about. We only care about <code class="language-plaintext highlighter-rouge">ld</code>/<code class="language-plaintext highlighter-rouge">sd</code> (or <code class="language-plaintext highlighter-rouge">lw</code>/<code class="language-plaintext highlighter-rouge">sw</code> in 32-bit). There are
other stores and loads that can write the stack (like <code class="language-plaintext highlighter-rouge">flw</code>/<code class="language-plaintext highlighter-rouge">fsw</code>) so we have
to filter them before we query <code class="language-plaintext highlighter-rouge">isLoadFromStackSlot</code> and <code class="language-plaintext highlighter-rouge">isStoreToStackSlot</code>.
These two functions also give us the frame index (<code class="language-plaintext highlighter-rouge">FI</code>) that these instructions
are using.</p>

<h2>Frame indexes to registers</h2>

<p>Now we can start mapping frame indexes to registers. To do that we define
a mapping from frame indexes (represented as <code class="language-plaintext highlighter-rouge">unsigned</code>) and registers.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">107
108
</pre></td><td class="code"><pre>  <span class="k">using</span> <span class="n">FrameIndexToFPRTy</span> <span class="o">=</span> <span class="n">DenseMap</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">Register</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">FrameIndexToFPRTy</span> <span class="n">FrameIndexToFPR</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If a frame index cannot be mapped to a register (e.g. we ran out of them) then
we will map it to the special <code class="language-plaintext highlighter-rouge">RISCV::NoRegister</code> value. Otherwise it will be
mapped to one of the available registers computed above in <code class="language-plaintext highlighter-rouge">RegsAvailableFPR</code>.</p>

<p>But before we start mapping them, we need to take care of a detail: if a frame
index is used in an instruction other than one of the instructions we care
about, we should conservatively leave them alone. A way to achieve this is to
map them first to <code class="language-plaintext highlighter-rouge">RISCV::NoRegister</code>. We can use the helper <code class="language-plaintext highlighter-rouge">IsSpillReload</code> we
defined above to filter them.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
</pre></td><td class="code"><pre>  <span class="c1">// Check frame indexes in other instructions and assign them to NoRegister</span>
  <span class="c1">// to avoid replacing them.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">MBB</span> <span class="o">:</span> <span class="o">*</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
         <span class="n">MBBI</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="n">MBBI</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span> <span class="o">=</span> <span class="o">*</span><span class="n">MBBI</span><span class="p">;</span>

      <span class="kt">bool</span> <span class="n">SpillOrReload</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">FI</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">IsSpill</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">SpillOrReload</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">IsSpill</span><span class="p">)</span> <span class="o">=</span> <span class="n">IsSpillReload</span><span class="p">(</span><span class="n">MI</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">SpillOrReload</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">:</span> <span class="n">MI</span><span class="p">.</span><span class="n">operands</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isFI</span><span class="p">())</span>
          <span class="n">FrameIndexToFPR</span><span class="p">[</span><span class="n">MO</span><span class="p">.</span><span class="n">getIndex</span><span class="p">()]</span> <span class="o">=</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">NoRegister</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If the instruction is a spill or reload, we skip it. If it is not then we check
if one of its operand is a frame index (<code class="language-plaintext highlighter-rouge">MO.isFI()</code>). If it is, we preemptively
map that frame index (<code class="language-plaintext highlighter-rouge">MO.getIndex()</code>) to <code class="language-plaintext highlighter-rouge">RISCV::NoRegister</code>.</p>

<p>Now we can try to map the frame indexes into FPRs so we can move them to/from
FPRs. First we filter all the instructions that are not spills or reloads
of our interest.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
</pre></td><td class="code"><pre>  <span class="c1">// Now replace the spills and reloads.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">MBB</span> <span class="o">:</span> <span class="o">*</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">MBBI</span> <span class="o">!=</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">NMBBI</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">next</span><span class="p">(</span><span class="n">MBBI</span><span class="p">);</span>

      <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span> <span class="o">=</span> <span class="o">*</span><span class="n">MBBI</span><span class="p">;</span>
      <span class="n">MBBI</span> <span class="o">=</span> <span class="n">NMBBI</span><span class="p">;</span>

      <span class="kt">bool</span> <span class="n">SpillOrReload</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">FI</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">IsSpill</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">SpillOrReload</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">IsSpill</span><span class="p">)</span> <span class="o">=</span> <span class="n">IsSpillReload</span><span class="p">(</span><span class="n">MI</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SpillOrReload</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Note also the way we need to iterate through the instructions: we are going to
replace instructions as we find them so this loop should be resilient to
changing the list of instructions of the basic block.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
</pre></td><td class="code"><pre>      <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Found "</span><span class="p">);</span>
      <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">MI</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()));</span>

      <span class="n">FrameIndexToFPRTy</span><span class="o">::</span><span class="n">iterator</span> <span class="n">ItR</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">FINotFound</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">ItR</span><span class="p">,</span> <span class="n">FINotFound</span><span class="p">)</span> <span class="o">=</span>
          <span class="n">FrameIndexToFPR</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">FI</span><span class="p">,</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">NoRegister</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">FINotFound</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Try to find a suitable free FPR.</span>
        <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()</span>
                   <span class="o">&lt;&lt;</span> <span class="s">"Trying to find a free FPR for index "</span> <span class="o">&lt;&lt;</span> <span class="n">FI</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">Register</span> <span class="n">R</span> <span class="o">=</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">NoRegister</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">RegsAvailableFPR</span><span class="p">.</span><span class="n">find_first</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">RegsAvailableFPR</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">Idx</span><span class="p">);</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ItR</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">R</span> <span class="o">!=</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">NoRegister</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">RemoveStackObject</span><span class="p">(</span><span class="n">FI</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We found a spill or reload. We check first if its frame index had already been mapped.
If it hadn’t been mapped (as stated by <code class="language-plaintext highlighter-rouge">FINotFound</code>) we try to find a register
in the bitvectors we computed above. If we find one <code class="language-plaintext highlighter-rouge">Idx &gt; 0</code> then we mark it as
used and we make the current frame index map to it (line 164). If we actually
mapped this frame index, we need to make sure it is not emitted as a stack object, so
we remove it from the <code class="language-plaintext highlighter-rouge">MachineFrameInfo</code> (line 168).</p>

<p>Now we can make the mapping effective.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">172
173
174
175
176
177
</pre></td><td class="code"><pre>      <span class="n">Register</span> <span class="n">R</span> <span class="o">=</span> <span class="n">ItR</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">R</span> <span class="o">==</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">NoRegister</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()</span>
                   <span class="o">&lt;&lt;</span> <span class="s">"No register is available for index "</span> <span class="o">&lt;&lt;</span> <span class="n">FI</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>If it was not mapped to anything, just ignore this instruction. Otherwise we can
do the map. Basically we need to create a <code class="language-plaintext highlighter-rouge">fmv.d.x</code> (or <code class="language-plaintext highlighter-rouge">fmv.w.x</code>) instruction
for spills and <code class="language-plaintext highlighter-rouge">fmv.x.d</code> (or <code class="language-plaintext highlighter-rouge">fmv.x.w</code>) for reloads.</p>

<figure class="highlight"><figcaption>llvm/lib/Target/RISCV/RISCVSoftenSpills.cpp</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
</pre></td><td class="code"><pre>      <span class="c1">// Ok so we found a suitable FPR, let's use that one.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">IsSpill</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span>
            <span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">is64Bit</span><span class="p">()</span> <span class="o">?</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">FMV_D_X</span> <span class="o">:</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">FMV_W_X</span><span class="p">;</span>
        <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">NewMI</span> <span class="o">=</span>
            <span class="o">*</span><span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MI</span><span class="p">,</span> <span class="n">MI</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">(),</span> <span class="n">TII</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Opcode</span><span class="p">),</span> <span class="n">R</span><span class="p">)</span>
                 <span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getReg</span><span class="p">());</span>

        <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Replacing with "</span><span class="p">);</span>
        <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">NewMI</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()));</span>
        <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span>
            <span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">is64Bit</span><span class="p">()</span> <span class="o">?</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">FMV_X_D</span> <span class="o">:</span> <span class="n">RISCV</span><span class="o">::</span><span class="n">FMV_X_W</span><span class="p">;</span>
        <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">NewMI</span> <span class="o">=</span>
            <span class="o">*</span><span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MI</span><span class="p">,</span> <span class="n">MI</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">(),</span> <span class="n">TII</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Opcode</span><span class="p">),</span>
                     <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getReg</span><span class="p">())</span>
                 <span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>

        <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Replacing with "</span><span class="p">);</span>
        <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">NewMI</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()));</span>
        <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">MI</span><span class="p">.</span><span class="n">eraseFromParent</span><span class="p">();</span>
      <span class="n">Changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>In line 186 (or line 196 for reloads) we create a new instruction using the
helper <code class="language-plaintext highlighter-rouge">BuildMI</code>. For spills (line 187) we write into the register <code class="language-plaintext highlighter-rouge">R</code>, that we
computed above. What we write is the first operand of this store, which is
exactly the register being stored into memory.</p>

<p>So we go from something like</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">sd x10, &lt;frame-index.1&gt;, 0   # here 0 is the offset of the memory operand
                             # it is 0 because it was unknown when this spill
                             # was created</code></pre></figure>

<p>into something like</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">fmv.d.x f4, x10</code></pre></figure>

<p>In this example <code class="language-plaintext highlighter-rouge">&lt;frame-index.1&gt;</code> would be associated to the register
<code class="language-plaintext highlighter-rouge">f4</code>.</p>

<h2>Show me the code!</h2>

<p>Find the pass <a href="https://gist.github.com/rofirrim/a91b0b80662d1ca2a7fedc2d2cc21da7">here</a>.</p>

<h1>Wrap-up</h1>

<p>This has been a very long post, so in the <a href="/2020/06/20/forgotten-memories-2/">next one</a>
we will see what are the results of this experiment, along with other issues I
found in the way.</p>

  </div>

</article>

<div class="pagination">

  <a class="previous" href="/2020/06/06/local-domain-and-dhcp-with-dnsmasq/">&laquo; Create your own local domain and DHCP with dnsmasq</a>


  <a class="next" href="/2020/06/20/forgotten-memories-2/">Forgotten memories (2) &raquo;</a>

</div>



      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Powered by <a href="https://jekyllrb.com">Jekyll</a>. Theme based on <a href="https://github.com/yous/whiteglass">whiteglass</a>
<br>
Subscribe via <a href="https://thinkingeek.com/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
