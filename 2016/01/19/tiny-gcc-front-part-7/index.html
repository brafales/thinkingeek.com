<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>A tiny GCC front end – Part 7</title>
  <meta name="description" content="In this part we will complete the missing statements from part 6 and finish our front end.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://thinkingeek.com/2016/01/19/tiny-gcc-front-part-7/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Think In Geek" href="https://thinkingeek.com/feed.xml">

  

  
  <meta property="og:title" content="A tiny GCC front end – Part 7">
  <meta property="og:site_name" content="Think In Geek">
  <meta property="og:url" content="https://thinkingeek.com/2016/01/19/tiny-gcc-front-part-7/">
  <meta property="og:description" content="In this part we will complete the missing statements from part 6 and finish our front end.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="A tiny GCC front end – Part 7">
  <meta name="twitter:description" content="In this part we will complete the missing statements from part 6 and finish our front end.">
  
  

  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
<link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

      <span class="site-title"><a href="/">Think In Geek</a> | </span>
      <span class="site-slogan">In geek we trust</span>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/arm-assembler-raspberry-pi/">Arm Assembler Raspberry Pi</a>
      
        
        <a class="page-link" href="/gcc-tiny/">GCC tiny</a>
      
        
        <a class="page-link" href="/author/brafales/">Posts by Bernat Ràfales</a>
      
        
        <a class="page-link" href="/archives/">Archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">A tiny GCC front end – Part 7</h1>
    
    <p class="post-meta"><time datetime="2016-01-19T23:28:52+00:00" itemprop="datePublished">Jan 19, 2016</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/compilers/">Compilers</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/gcc/">GCC</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  


 •
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/gcc/">gcc</a>,
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/tags/tiny/">tiny</a>
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>
In this part we will complete the missing statements from part 6 and finish our front end.
</p>

<!--more-->

<h2>Read statement</h2>

<p>
A read statement is a bit like the dual of a write statement. We will implement it using a call to <code>scanf</code>.
</p>

<p style="padding: 0.7em; background-color: #e0e0e0;">
〈read〉&ensp;→&ensp;<code><strong>read</strong></code> 〈identifier〉 <code><strong>;</strong></code>
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="n">Tree</span>
<span class="n">Parser</span><span class="o">::</span><span class="n">parse_read_statement</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">READ</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">skip_after_semicolon</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">const_TokenPtr</span> <span class="n">first_of_expr</span> <span class="o">=</span> <span class="n">lexer</span><span class="p">.</span><span class="n">peek_token</span> <span class="p">();</span>
  <span class="n">Tree</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">parse_expression</span> <span class="p">();</span>

  <span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">SEMICOLON</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">is_error</span> <span class="p">())</span>
    <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_tree_code</span> <span class="p">()</span> <span class="o">!=</span> <span class="n">VAR_DECL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">error_at</span> <span class="p">(</span><span class="n">first_of_expr</span><span class="o">-&gt;</span><span class="n">get_locus</span> <span class="p">(),</span>
		<span class="s">"invalid expression in read statement"</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="c1">// Now this variable must be addressable</span>
  <span class="n">TREE_ADDRESSABLE</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_tree</span> <span class="p">())</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_type</span> <span class="p">()</span> <span class="o">==</span> <span class="n">integer_type_node</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">format</span> <span class="o">=</span> <span class="s">"%d"</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_type</span> <span class="p">()</span> <span class="o">==</span> <span class="n">float_type_node</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">format</span> <span class="o">=</span> <span class="s">"%f"</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">error_at</span> <span class="p">(</span><span class="n">first_of_expr</span><span class="o">-&gt;</span><span class="n">get_locus</span> <span class="p">(),</span>
		<span class="s">"variable of type %s is not a valid read operand"</span><span class="p">,</span>
		<span class="n">print_type</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_type</span> <span class="p">()));</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">tree</span> <span class="n">args</span><span class="p">[]</span>
    <span class="o">=</span> <span class="p">{</span><span class="n">build_string_literal</span> <span class="p">(</span><span class="n">strlen</span> <span class="p">(</span><span class="n">format</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">format</span><span class="p">),</span>
       <span class="n">build_tree</span> <span class="p">(</span><span class="n">ADDR_EXPR</span><span class="p">,</span> <span class="n">first_of_expr</span><span class="o">-&gt;</span><span class="n">get_locus</span> <span class="p">(),</span>
		   <span class="n">build_pointer_type</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_type</span> <span class="p">().</span><span class="n">get_tree</span> <span class="p">()),</span> <span class="n">expr</span><span class="p">)</span>
	 <span class="p">.</span><span class="n">get_tree</span> <span class="p">()};</span>

  <span class="n">Tree</span> <span class="n">scanf_fn</span> <span class="o">=</span> <span class="n">get_scanf_addr</span> <span class="p">();</span>

  <span class="n">tree</span> <span class="n">stmt</span>
    <span class="o">=</span> <span class="n">build_call_array_loc</span> <span class="p">(</span><span class="n">first_of_expr</span><span class="o">-&gt;</span><span class="n">get_locus</span> <span class="p">(),</span> <span class="n">integer_type_node</span><span class="p">,</span>
			    <span class="n">scanf_fn</span><span class="p">.</span><span class="n">get_tree</span> <span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">stmt</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
Here we depart a bit from the specification in part 1 because it says that a read statement expects an identifier. We abuse a bit <code>parse_expression</code> (line 11) and we force it to be a variable name (lines 18 to 23). Of course we could have manually looked up the identifier token. But <code>parse_expression</code> does this for us anyway, why not use it? Note that this strategy could be applied to the left part of the assignment statement.
</p>

<p>
Now comes an interesting aspect of GENERIC: <code>VAR_DECL</code>s do not have to be in memory. We want <code>scanf</code> to update our variable and the only way to do this is by passing to <code>scanf</code> the address of the variable. So we have to state that this variable will have its address computed (line 26). Failing to do this, GCC would create a temporary from our variable and would use that one instead: our variable would stay untouched.
</p>

<p>
We then prepare the call to <code>scanf</code>, first we set the appropiate format string depending on the type of the variable (lines 28 to 43). Then we build the arguments to <code>scanf</code>. The first one is the format string as a string literal (line 46) and the second one (line 47) is an <code>ADDR_EXPR</code>. This tree means getting the address of its operand. The type of this expression should be a pointer type to our variable. Similar to what we did with <code>puts</code> and <code>printf</code> in the write statement, we get the address of <code>scanf</code> (line 51). Finally everything is set to make the call to scanf (line 55).
</p>

<h2>If statement</h2>

<p style="padding: 0.7em; background-color: #e0e0e0;">
〈if〉&ensp;→&ensp;<code><strong>if</strong></code> 〈expression〉 <code><strong>then</strong></code> 〈statement〉* <code><strong>end</strong></code>
&emsp;&emsp; | <code><strong>if</strong></code> 〈expression〉 <code><strong>then</strong></code> 〈statement〉* <code><strong>else</strong></code> 〈statement〉* <code><strong>end</strong></code>
</p>

<p>
Control statements are a bit more complicated than other statements so we will split the parsing proper and the GENERIC tree construction. You will also see that the tree synthesized for these control statements is often a TreeStmtList: the implementation of these statements require several GENERIC trees. Let's see first how to parse an if statement.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="n">Tree</span>
<span class="n">Parser</span><span class="o">::</span><span class="n">parse_if_statement</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">IF</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">skip_after_end</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">Tree</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">parse_boolean_expression</span> <span class="p">();</span>

  <span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">THEN</span><span class="p">);</span>

  <span class="n">enter_scope</span> <span class="p">();</span>
  <span class="n">parse_statement_seq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">Parser</span><span class="o">::</span><span class="n">done_end_or_else</span><span class="p">);</span>

  <span class="n">TreeSymbolMapping</span> <span class="n">then_tree_scope</span> <span class="o">=</span> <span class="n">leave_scope</span> <span class="p">();</span>
  <span class="n">Tree</span> <span class="n">then_stmt</span> <span class="o">=</span> <span class="n">then_tree_scope</span><span class="p">.</span><span class="n">bind_expr</span><span class="p">;</span>

  <span class="n">Tree</span> <span class="n">else_stmt</span><span class="p">;</span>
  <span class="n">const_TokenPtr</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">lexer</span><span class="p">.</span><span class="n">peek_token</span> <span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">get_id</span> <span class="p">()</span> <span class="o">==</span> <span class="n">Tiny</span><span class="o">::</span><span class="n">ELSE</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// Consume 'else'</span>
      <span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">ELSE</span><span class="p">);</span>

      <span class="n">enter_scope</span> <span class="p">();</span>
      <span class="n">parse_statement_seq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">Parser</span><span class="o">::</span><span class="n">done_end</span><span class="p">);</span>
      <span class="n">TreeSymbolMapping</span> <span class="n">else_tree_scope</span> <span class="o">=</span> <span class="n">leave_scope</span> <span class="p">();</span>
      <span class="n">else_stmt</span> <span class="o">=</span> <span class="n">else_tree_scope</span><span class="p">.</span><span class="n">bind_expr</span><span class="p">;</span>

      <span class="c1">// Consume 'end'</span>
      <span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">END</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="o">-&gt;</span><span class="n">get_id</span> <span class="p">()</span> <span class="o">==</span> <span class="n">Tiny</span><span class="o">::</span><span class="n">END</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// Consume 'end'</span>
      <span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">END</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">unexpected_token</span> <span class="p">(</span><span class="n">tok</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">build_if_statement</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">then_stmt</span><span class="p">,</span> <span class="n">else_stmt</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
It is not uncommon in control structures to find expressions that are slightly more restricted than the general expressions. It makes sense, thus, to parse the condition expression using a specialized function <code>parse_boolean_expression</code> (line 10) that verifies that the expression has boolean type.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Tree</span>
<span class="n">Parser</span><span class="o">::</span><span class="n">parse_boolean_expression</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="n">Tree</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">parse_expression</span> <span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">is_error</span> <span class="p">())</span>
    <span class="k">return</span> <span class="n">expr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_type</span> <span class="p">()</span> <span class="o">!=</span> <span class="n">boolean_type_node</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">error_at</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span>
		<span class="s">"expected expression of boolean type but its type is %s"</span><span class="p">,</span>
		<span class="n">print_type</span> <span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">get_type</span> <span class="p">()));</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="n">expr</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>
Both the <em>then</em> part and the <em>else</em> part of an if statement are 〈statement〉*. According to the tiny definition, there is a new symbol mapping for them. So we simply enter the scope, parse the statement sequence and then leave the scope to get the <code>BIND_EXPR</code> of the block (lines 14 to 18). We do the same if there is an else part (lines 27 to 30).
</p>

<p>
Now we call the function <code>build_if_statement</code> that will be the responsible for building the GENERIC tree of this if statement (line 46).
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre><span class="n">Tree</span>
<span class="n">Parser</span><span class="o">::</span><span class="n">build_if_statement</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">bool_expr</span><span class="p">,</span> <span class="n">Tree</span> <span class="n">then_part</span><span class="p">,</span> <span class="n">Tree</span> <span class="n">else_part</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bool_expr</span><span class="p">.</span><span class="n">is_error</span> <span class="p">())</span>
    <span class="k">return</span> <span class="n">bool_expr</span><span class="p">;</span>

  <span class="n">Tree</span> <span class="n">then_label_decl</span> <span class="o">=</span> <span class="n">build_label_decl</span> <span class="p">(</span><span class="s">"then"</span><span class="p">,</span> <span class="n">then_part</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">());</span>

  <span class="n">Tree</span> <span class="n">else_label_decl</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">else_part</span><span class="p">.</span><span class="n">is_null</span> <span class="p">())</span>
    <span class="n">else_label_decl</span> <span class="o">=</span> <span class="n">build_label_decl</span> <span class="p">(</span><span class="s">"else"</span><span class="p">,</span> <span class="n">else_part</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">());</span>

  <span class="n">Tree</span> <span class="n">endif_label_decl</span> <span class="o">=</span> <span class="n">build_label_decl</span> <span class="p">(</span><span class="s">"end_if"</span><span class="p">,</span> <span class="n">then_part</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">());</span>

  <span class="n">Tree</span> <span class="n">goto_then</span> <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">GOTO_EXPR</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span>
			       <span class="n">void_type_node</span><span class="p">,</span> <span class="n">then_label_decl</span><span class="p">);</span>
  <span class="n">Tree</span> <span class="n">goto_endif</span> <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">GOTO_EXPR</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span>
				<span class="n">void_type_node</span><span class="p">,</span> <span class="n">endif_label_decl</span><span class="p">);</span>

  <span class="n">Tree</span> <span class="n">goto_else_or_endif</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">else_part</span><span class="p">.</span><span class="n">is_null</span> <span class="p">())</span>
    <span class="n">goto_else_or_endif</span> <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">GOTO_EXPR</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span>
				     <span class="n">void_type_node</span><span class="p">,</span> <span class="n">else_label_decl</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">goto_else_or_endif</span> <span class="o">=</span> <span class="n">goto_endif</span><span class="p">;</span>

  <span class="n">TreeStmtList</span> <span class="n">stmt_list</span><span class="p">;</span>

  <span class="n">Tree</span> <span class="n">cond_expr</span>
    <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">COND_EXPR</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span> <span class="n">void_type_node</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">,</span>
		  <span class="n">goto_then</span><span class="p">,</span> <span class="n">goto_else_or_endif</span><span class="p">);</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">cond_expr</span><span class="p">);</span>

  <span class="n">Tree</span> <span class="n">then_label_expr</span> <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">LABEL_EXPR</span><span class="p">,</span> <span class="n">then_part</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span>
				     <span class="n">void_type_node</span><span class="p">,</span> <span class="n">then_label_decl</span><span class="p">);</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">then_label_expr</span><span class="p">);</span>

  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">then_part</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">else_part</span><span class="p">.</span><span class="n">is_null</span> <span class="p">())</span>
    <span class="p">{</span>
      <span class="c1">// Make sure after then part has been executed we go to the end if</span>
      <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">goto_endif</span><span class="p">);</span>

      <span class="n">Tree</span> <span class="n">else_label_expr</span> <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">LABEL_EXPR</span><span class="p">,</span> <span class="n">else_part</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span>
					 <span class="n">void_type_node</span><span class="p">,</span> <span class="n">else_label_decl</span><span class="p">);</span>
      <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">else_label_expr</span><span class="p">);</span>

      <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">else_part</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="n">Tree</span> <span class="n">endif_label_expr</span> <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">LABEL_EXPR</span><span class="p">,</span> <span class="n">UNKNOWN_LOCATION</span><span class="p">,</span>
				      <span class="n">void_type_node</span><span class="p">,</span> <span class="n">endif_label_decl</span><span class="p">);</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">endif_label_expr</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">stmt_list</span><span class="p">.</span><span class="n">get_tree</span> <span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
When GENERIC trees were introduced in part 5 we said that some of them can be classified as declarations. We have mostly used <code>VAR_DECL</code>s and some function declarations (albeit indirectly for calls and the main function). Now we will need <code>LABEL_DECL</code>s. These trees represent the mere existence of a label. Since each label must be linked to its function, that in tiny it will be the main, we will use an auxiliar function to create them.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Tree</span>
<span class="n">Parser</span><span class="o">::</span><span class="n">build_label_decl</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">location_t</span> <span class="n">loc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">tree</span> <span class="n">t</span> <span class="o">=</span> <span class="n">build_decl</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">LABEL_DECL</span><span class="p">,</span> <span class="n">get_identifier</span> <span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">void_type_node</span><span class="p">);</span>

  <span class="n">gcc_assert</span> <span class="p">(</span><span class="n">main_fndecl</span> <span class="o">!=</span> <span class="n">NULL_TREE</span><span class="p">);</span>
  <span class="n">DECL_CONTEXT</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">main_fndecl</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>
Labels represent locations of our program (in contrast to variables that represent data). The location represented by a label is defined by a <code>LABEL_EXPR</code> tree. Once a label has been defined, then we can use it to change the program execution to that label. Lists of statements implicitly execute in sequence unless a <code>GOTO_EXPR</code> changes the control flow.
</p>

<p>
Back to the implementation of the if statement, we start by creating 2 or 3 labels: one for the then part, another for the else part (if any) and another one for the end if (lines 7 to 13).
</p>

<p>
An if statement will first evaluate its condition, that we have represented in the parameter bool_expr. If this expression is true the program will branch to the then part, otherwise if there is else the program will branch to the else part. If there is no else part and the condition does not evaluate to true we will branch directly to the end of the if. When a then part ends it will also have to branch to the end of the if. The else part does not have to branch to end if, as implicit sequencing will achieve the same.
</p>

<p>
Branching is achieved using <code>GOTO_EXPR</code> trees. So the first thing we do is creating several <code>GOTO_EXPR</code>s (lines 15 to 25). Now we need to perform the conditional branching. This is done using a tree <code>COND_EXPR</code>, its three operands are the boolean expression, the true expression and the false expression. We will branch to the then part in the true expression and to the else part or the end of the if for the false expression (line 30). We will create a statement list for the if statement (line 27) where we will append all the statements required to implement an if statement. Obviously the <code>COND_EXPR</code> tree goes first (line 32).
</p>

<p>
Now we define the location related to the then part. We do that by creating a <code>LABEL_EXPR</code> tree for the label declaration of the then part (line 34) and we append it to the statement list (line 36). Now we append the tree <code>then_part</code> that we got as a parameter and that contains the then part parsed above (line 38).
</p>

<p>
If there is else part we append a goto endif, so the then part branches to the end of the if when completed (line 43). Similarly to the then part, we define the location of the else label (line 45), we append it (line 47) and then we append the else part tree that we got in the parameter <code>else_part</code> (line 49). As we said above, there is no need to jump to end if in the else part.
</p>

<p>
Finally we define the label for the end if (lines 52 and 53), append it to the statement list (line 54) before we just return it (line 56).
</p>

<h2>While statement</h2>

<p>
We will use the same strategy for the while statement: first parse its syntactic elements and then build a statement list to implement it.
</p>

<p style="padding: 0.7em; background-color: #e0e0e0;">
〈while〉&ensp;→&ensp;<code><strong>while</strong></code> 〈expression〉 <code><strong>do</strong></code> 〈statement〉* <code><strong>end</strong></code>
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Tree</span>
<span class="n">Parser</span><span class="o">::</span><span class="n">parse_while_statement</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">WHILE</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">skip_after_end</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">Tree</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">parse_boolean_expression</span> <span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">DO</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">skip_after_end</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">enter_scope</span> <span class="p">();</span>
  <span class="n">parse_statement_seq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">Parser</span><span class="o">::</span><span class="n">done_end</span><span class="p">);</span>
  <span class="n">TreeSymbolMapping</span> <span class="n">while_body_tree_scope</span> <span class="o">=</span> <span class="n">leave_scope</span> <span class="p">();</span>

  <span class="n">Tree</span> <span class="n">while_body_stmt</span> <span class="o">=</span> <span class="n">while_body_tree_scope</span><span class="p">.</span><span class="n">bind_expr</span><span class="p">;</span>

  <span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">END</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">build_while_statement</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">while_body_stmt</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>
Parsing a while statement is relatively easy: a condition expression of boolean type and then a body. We then call <code>build_while_statement</code> with these two parts.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="n">Tree</span>
<span class="n">Parser</span><span class="o">::</span><span class="n">build_while_statement</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">bool_expr</span><span class="p">,</span> <span class="n">Tree</span> <span class="n">while_body</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bool_expr</span><span class="p">.</span><span class="n">is_error</span> <span class="p">())</span>
    <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>

  <span class="n">TreeStmtList</span> <span class="n">stmt_list</span><span class="p">;</span>

  <span class="n">Tree</span> <span class="n">while_check_label_decl</span>
    <span class="o">=</span> <span class="n">build_label_decl</span> <span class="p">(</span><span class="s">"while_check"</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">());</span>

  <span class="n">Tree</span> <span class="n">while_check_label_expr</span>
    <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">LABEL_EXPR</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span> <span class="n">void_type_node</span><span class="p">,</span>
		  <span class="n">while_check_label_decl</span><span class="p">);</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">while_check_label_expr</span><span class="p">);</span>

  <span class="n">Tree</span> <span class="n">while_body_label_decl</span>
    <span class="o">=</span> <span class="n">build_label_decl</span> <span class="p">(</span><span class="s">"while_body"</span><span class="p">,</span> <span class="n">while_body</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">());</span>
  <span class="n">Tree</span> <span class="n">end_of_while_label_decl</span>
    <span class="o">=</span> <span class="n">build_label_decl</span> <span class="p">(</span><span class="s">"end_of_while"</span><span class="p">,</span> <span class="n">UNKNOWN_LOCATION</span><span class="p">);</span>

  <span class="n">Tree</span> <span class="n">cond_expr</span>
    <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">COND_EXPR</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span> <span class="n">void_type_node</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">,</span>
		  <span class="n">build_tree</span> <span class="p">(</span><span class="n">GOTO_EXPR</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span> <span class="n">void_type_node</span><span class="p">,</span>
			      <span class="n">while_body_label_decl</span><span class="p">),</span>
		  <span class="n">build_tree</span> <span class="p">(</span><span class="n">GOTO_EXPR</span><span class="p">,</span> <span class="n">bool_expr</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span> <span class="n">void_type_node</span><span class="p">,</span>
			      <span class="n">end_of_while_label_decl</span><span class="p">));</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">cond_expr</span><span class="p">);</span>

  <span class="n">Tree</span> <span class="n">while_body_label_expr</span>
    <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">LABEL_EXPR</span><span class="p">,</span> <span class="n">while_body</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span> <span class="n">void_type_node</span><span class="p">,</span>
		  <span class="n">while_body_label_decl</span><span class="p">);</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">while_body_label_expr</span><span class="p">);</span>

  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">while_body</span><span class="p">);</span>

  <span class="n">Tree</span> <span class="n">goto_check</span> <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">GOTO_EXPR</span><span class="p">,</span> <span class="n">UNKNOWN_LOCATION</span><span class="p">,</span> <span class="n">void_type_node</span><span class="p">,</span>
				<span class="n">while_check_label_decl</span><span class="p">);</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">goto_check</span><span class="p">);</span>

  <span class="n">Tree</span> <span class="n">end_of_while_label_expr</span>
    <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">LABEL_EXPR</span><span class="p">,</span> <span class="n">UNKNOWN_LOCATION</span><span class="p">,</span> <span class="n">void_type_node</span><span class="p">,</span>
		  <span class="n">end_of_while_label_decl</span><span class="p">);</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">end_of_while_label_expr</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">stmt_list</span><span class="p">.</span><span class="n">get_tree</span> <span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
We start by creating a label for the condition check (line 10) and defining its location that we will append to the statement list (lines 12 to 15). Then we define two other labels one for the body of the loop and one to end the loop (lines 17 to 20). Now we add a COND_EXPR tree that evaluates the condition expression. It will branch to the body of the loop when the condition is true, to the end of the while otherwise (lines 22 to 28). Then we define the location of the label for the body of the loop  (lines 30 to 33) and append the while body (line 35). Then we have to branch back (this is why it is a loop) to the condition check (lines 37 to 39). Then we just define the location of the label for the end of the while (lines 41 to 44). Our while statement is done, so let's return it (line 46).
</p>

<h2>For-statement</h2>

<p style="padding: 0.7em; background-color: #e0e0e0;">
〈for〉&ensp;→&ensp;<code><strong>for</strong></code> 〈identifier〉 <code><strong>:=</strong></code> 〈expression〉 <code><strong>to</strong></code> 〈expression〉 <code><strong>do</strong></code> 〈statement〉* <code><strong>end</strong></code>
</p>

<p>
If you recall part 1, we defined a for statement like the following
</p>

<figure class="highlight"><pre><code class="language-pascal" data-lang="pascal"><span class="k">for</span> <span class="n">id</span> <span class="p">:=</span> <span class="n">L</span> <span class="k">to</span> <span class="n">U</span> <span class="k">do</span>
  <span class="n">S</span>
<span class="k">end</span></code></pre></figure>

<p>
to be semantically equivalent to
</p>

<figure class="highlight"><pre><code class="language-pascal" data-lang="pascal"><span class="n">id</span> <span class="p">:=</span> <span class="n">L</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">id</span> <span class="p">&lt;=</span> <span class="n">U</span><span class="p">)</span> <span class="k">do</span>
 <span class="n">S</span>
 <span class="n">id</span> <span class="p">:=</span> <span class="n">id</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
<span class="k">end</span></code></pre></figure>

<p>
Now we will appreciate that it has paid off to create a <code>build_while_statement</code> function. But first we parse the for statement.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Parser</span><span class="o">::</span><span class="n">parse_for_statement</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">FOR</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">skip_after_end</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">const_TokenPtr</span> <span class="n">identifier</span> <span class="o">=</span> <span class="n">expect_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">IDENTIFIER</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">identifier</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">skip_after_end</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">ASSIG</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">skip_after_end</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">Tree</span> <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">parse_integer_expression</span> <span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">TO</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">skip_after_end</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">Tree</span> <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">parse_integer_expression</span> <span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">DO</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">skip_after_end</span> <span class="p">();</span>
      <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
    <span class="p">}</span>

  <span class="n">enter_scope</span> <span class="p">();</span>
  <span class="n">parse_statement_seq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">Parser</span><span class="o">::</span><span class="n">done_end</span><span class="p">);</span>

  <span class="n">TreeSymbolMapping</span> <span class="n">for_body_tree_scope</span> <span class="o">=</span> <span class="n">leave_scope</span> <span class="p">();</span>
  <span class="n">Tree</span> <span class="n">for_body_stmt</span> <span class="o">=</span> <span class="n">for_body_tree_scope</span><span class="p">.</span><span class="n">bind_expr</span><span class="p">;</span>

  <span class="n">skip_token</span> <span class="p">(</span><span class="n">Tiny</span><span class="o">::</span><span class="n">END</span><span class="p">);</span>

  <span class="c1">// Induction var</span>
  <span class="n">SymbolPtr</span> <span class="n">ind_var</span>
    <span class="o">=</span> <span class="n">query_integer_variable</span> <span class="p">(</span><span class="n">identifier</span><span class="o">-&gt;</span><span class="n">get_str</span> <span class="p">(),</span> <span class="n">identifier</span><span class="o">-&gt;</span><span class="n">get_locus</span> <span class="p">());</span>

  <span class="k">return</span> <span class="n">build_for_statement</span> <span class="p">(</span><span class="n">ind_var</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">for_body_stmt</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>
Now <code>build_for_statement</code> just creates the statements shown above. The variable of the for statement is commonly known as the <em>induction variable</em>.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="n">Tree</span>
<span class="n">Parser</span><span class="o">::</span><span class="n">build_for_statement</span> <span class="p">(</span><span class="n">SymbolPtr</span> <span class="n">ind_var</span><span class="p">,</span> <span class="n">Tree</span> <span class="n">lower_bound</span><span class="p">,</span>
			     <span class="n">Tree</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">Tree</span> <span class="n">for_body_stmt_list</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ind_var</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>
  <span class="n">Tree</span> <span class="n">ind_var_decl</span> <span class="o">=</span> <span class="n">ind_var</span><span class="o">-&gt;</span><span class="n">get_tree_decl</span> <span class="p">();</span>

  <span class="c1">// Lower</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lower_bound</span><span class="p">.</span><span class="n">is_error</span> <span class="p">())</span>
    <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>

  <span class="c1">// Upper</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">upper_bound</span><span class="p">.</span><span class="n">is_error</span> <span class="p">())</span>
    <span class="k">return</span> <span class="n">Tree</span><span class="o">::</span><span class="n">error</span> <span class="p">();</span>

  <span class="c1">// ind_var := lower;</span>
  <span class="n">TreeStmtList</span> <span class="n">stmt_list</span><span class="p">;</span>

  <span class="n">Tree</span> <span class="n">init_ind_var</span> <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">MODIFY_EXPR</span><span class="p">,</span> <span class="n">UNKNOWN_LOCATION</span><span class="p">,</span>
				  <span class="n">void_type_node</span><span class="p">,</span> <span class="n">ind_var_decl</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">);</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">init_ind_var</span><span class="p">);</span>

  <span class="c1">// ind_var &lt;= upper</span>
  <span class="n">Tree</span> <span class="n">while_condition</span>
    <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">LE_EXPR</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">.</span><span class="n">get_locus</span> <span class="p">(),</span> <span class="n">boolean_type_node</span><span class="p">,</span>
		  <span class="n">ind_var_decl</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">);</span>

  <span class="c1">// for-body</span>
  <span class="c1">// ind_var := ind_var + 1</span>
  <span class="n">Tree</span> <span class="n">incr_ind_var</span>
    <span class="o">=</span> <span class="n">build_tree</span> <span class="p">(</span><span class="n">MODIFY_EXPR</span><span class="p">,</span> <span class="n">UNKNOWN_LOCATION</span><span class="p">,</span> <span class="n">void_type_node</span><span class="p">,</span>
		  <span class="n">ind_var_decl</span><span class="p">,</span>
		  <span class="n">build_tree</span> <span class="p">(</span><span class="n">PLUS_EXPR</span><span class="p">,</span> <span class="n">UNKNOWN_LOCATION</span><span class="p">,</span> <span class="n">integer_type_node</span><span class="p">,</span>
			      <span class="n">ind_var_decl</span><span class="p">,</span>
			      <span class="n">build_int_cst_type</span> <span class="p">(</span><span class="n">integer_type_node</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>

  <span class="c1">// Wrap as a stmt list</span>
  <span class="n">TreeStmtList</span> <span class="n">for_stmt_list</span> <span class="o">=</span> <span class="n">for_body_stmt_list</span><span class="p">;</span>
  <span class="n">for_stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">incr_ind_var</span><span class="p">);</span>

  <span class="c1">// construct the associated while statement</span>
  <span class="n">Tree</span> <span class="n">while_stmt</span>
    <span class="o">=</span> <span class="n">build_while_statement</span> <span class="p">(</span><span class="n">while_condition</span><span class="p">,</span> <span class="n">for_stmt_list</span><span class="p">.</span><span class="n">get_tree</span> <span class="p">());</span>
  <span class="n">stmt_list</span><span class="p">.</span><span class="n">append</span> <span class="p">(</span><span class="n">while_stmt</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">stmt_list</span><span class="p">.</span><span class="n">get_tree</span> <span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
First we need to initialize the induction variable with the value of the lower bound. We do this by using a <code>MODIFY_EXPR</code> tree, the same we used for an assignment statement (lines 20 to 22). We append this initialization to the list of statements that will be the whole for statement tree.
</p>

<p>
Then we define the condition that we will use for the while. In this case we simply compute <code>i &lt;= upper</code> (lines 25 to 27). 
</p>

<p>
Now we synthesize the increment of the induction variable, again we use a <code>MODIFY_EXPR</code> and a <code>PLUS_EXPR</code> that represents <code>ind_var := ind_var + 1</code> (lines 31 to 36). We append this increment to the body of the for statement (lines 39 and 40).

<p>
Next is a call to <code>build_while_statement</code> with the while condition built above (lines 25 to 27) and the body of the for statement plus the increment of the induction variable (line 44). This will return a tree with the while statement that we append to the initialization of the induction variable (line 45). Finally we return the whole list.
</p>

<h2>Completion</h2>

<p>
Ok, so far our front end is more or less complete since it implements all the statements and expressions we defined in part 1. Let's try it with some not-totally trivial examples.
</p>

<p>
The sum 1 + 2 + ... + 10
</p>


<figure class="highlight"><pre><code class="language-pascal" data-lang="pascal"><span class="p">#</span> <span class="k">for</span><span class="p">.</span><span class="n">tiny</span>
<span class="k">var</span> <span class="n">i</span> <span class="p">:</span> <span class="n">int</span><span class="p">;</span>
<span class="k">var</span> <span class="n">s</span> <span class="p">:</span> <span class="n">int</span><span class="p">;</span>
<span class="n">s</span> <span class="p">:=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="m">1</span> <span class="k">to</span> <span class="m">10</span> <span class="k">do</span>
  <span class="n">s</span> <span class="p">:=</span> <span class="n">s</span> <span class="p">+</span> <span class="n">i</span><span class="p">;</span>
<span class="k">end</span>
<span class="k">write</span> <span class="n">s</span><span class="p">;</span></code></pre></figure>



<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>gcctiny <span class="nt">-o</span> <span class="k">for for</span>.tiny
<span class="nv">$ </span>./for
55</code></pre></figure>


<p>
The square root computed using 100 steps of the Newton method.
</p>


<figure class="highlight"><pre><code class="language-pascal" data-lang="pascal"><span class="p">#</span> <span class="n">sqrt</span><span class="p">.</span><span class="n">tiny</span>
<span class="k">var</span> <span class="n">s</span> <span class="p">:</span> <span class="n">float</span><span class="p">;</span>
<span class="n">s</span> <span class="p">:=</span> <span class="m">2.0</span><span class="p">;</span>

<span class="k">var</span> <span class="n">i</span> <span class="p">:</span> <span class="n">int</span><span class="p">;</span>

<span class="k">var</span> <span class="n">x</span> <span class="p">:</span> <span class="n">float</span><span class="p">;</span>
<span class="n">x</span> <span class="p">:=</span> <span class="m">1.0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">i</span> <span class="p">:=</span> <span class="m">1</span> <span class="k">to</span> <span class="m">100</span> <span class="k">do</span>
  <span class="n">x</span> <span class="p">:=</span> <span class="m">0.5</span> <span class="p">*</span> <span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="n">s</span> <span class="p">/</span> <span class="n">x</span><span class="p">);</span>
<span class="k">end</span>

<span class="k">write</span> <span class="n">x</span><span class="p">;</span></code></pre></figure>



<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>gcctiny  <span class="nt">-o</span> sqrt sqrt.tiny 
<span class="nv">$ </span>./sqrt 
1.414214</code></pre></figure>


<h2>Github</h2>

<p>
I have uploaded all the code in my <a href="https://github.com/rofirrim/gcc-tiny">github</a>. The code is in <code>gcc/tiny</code>.
</p>

<h2>What next</h2>

<p>
While this post marks the end of this series there are still a few things possible to do for tiny.
</p>

<ul>
<li>Define a coercion (similar to that of binary operators) from the right hand side of the assignment to the left hand side, so we can write <code>x := i;</code> where <code>x</code> is a float and <code>i</code> is an int.</li>
<li>Add the possibility of defining boolean variables (<code>var b : bool</code>) along with the two boolean literals <code>true</code> and <code>false</code>.</li>
<li>Add array types (e.g <code>var a : int[10];</code>) and expressions to reference array elements <code>a[i]</code>, array literals like <code>[1, 2, 3, 4]</code>. Coercions between non-arrays and arrays, etc.</li>
<li>Add pointer types (e.g. <code>var p : -&gt;int</code>) along with two statements to reserve and free the memory (e.g <code>new p;</code> and <code>delete p;</code>). Assignment between pointers of the same type. Dereference of pointers (e.g. <code>-&gt;p := 3;</code>), etc.</li>
<li>and many, many more</li>
</ul>

<p>
That's all for today.
</p>
</p>

  </div>

</article>

<div class="pagination">

  <a class="previous" href="/2016/01/17/tiny-gcc-front-part-6/">&laquo; A tiny GCC front end – Part 6</a>


  <a class="next" href="/2016/01/30/tiny-gcc-front-part-8/">A tiny GCC front end – Part 8 &raquo;</a>

</div>



      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Powered by <a href="https://jekyllrb.com">Jekyll</a>. Theme based on <a href="https://github.com/yous/whiteglass">whiteglass</a>
<br>
Subscribe via <a href="https://thinkingeek.com/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
