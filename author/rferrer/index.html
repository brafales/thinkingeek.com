<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Posts by Roger Ferrer Ibáñez</title>
  <meta name="description" content="Fun with vectors in the Raspberry Pi 1 - Part 2 Jun 25, 2021• Roger Ferrer Ibáñez • vectors, raspberry pi 1, llvm, compilers, arm Ok so in the previous installment we discussed a bit how to generate code using the vector feature of the CPU of the Raspberry Pi 1. Let’s start hacking LLVM. Read on &amp;rarr; Fun with vectors in the Raspberry Pi 1 - Part 1 Jun 25, 2021• Roger Ferrer Ibáñez • vectors, raspberry pi 1, llvm, compilers, arm Long ago, we saw that the Raspberry Pi 1 has vector computation capabilities.. However to the best of my knowledge no compiler attempted to exploit the vector capability in general. I think we are going to have some fun in trying to fix this. Read on &amp;rarr; RAII, locks and clang-tidy Mar 1, 2021• Roger Ferrer Ibáñez • c++, raii, clang-tidy, locks A colleague of mine spent some time chasing a bug in a C++ library related to concurrency. At the end it all boiled down to a silly declaration that wasn’t one. Read on &amp;rarr; Process-wide information and Linux key management Nov 22, 2020• Roger Ferrer Ibáñez • linux, libraries, programming I believe this is not a very common scenario, but sometimes one has to develop libraries whose scope is the whole process. In such a situation, we may need to identify if a process has already loaded another copy of the library. Read on &amp;rarr; Forgotten memories (2) Jun 20, 2020• Roger Ferrer Ibáñez • compilers, llvm, risc-v So in the first part of this experiment we saw a simple strategy to spill general-purpose registers into floating-point registers implemented in the RISC-V backend of LLVM. In this chapter, let’s see the results and some other interesting facts learnt during the process. Read on &amp;rarr; Forgotten memories (1) Jun 20, 2020• Roger Ferrer Ibáñez • compilers, llvm, risc-v Most compiler infrastructures that target register machines do it by using the concept of virtual registers. In their intermediate representations instructions use virtual registers to represent their operands. Because hardware is finite, these virtual registers must be mapped to physical registers at some point. The compiler does this in a process called register allocation. Being physical registers finite, it may happen that not all the virtual registers used by the program can be held in physical registers at the same time. When this happens, the compiler must emit spill code. Spill code stores a value in a memory (spill) and loads it later, often close to the point of use (reload). The memory used for spill code is commonly the function stack. However nothing prevents us from using other kinds of “memories” as long as we can guarantee that nobody is going to use them. This is exactly the kind of experiment we will do today: we’re going to spill general-purpose registers into floating-point registers. Read on &amp;rarr; Create your own local domain and DHCP with dnsmasq Jun 6, 2020• Roger Ferrer Ibáñez • dns, dhcp Back in 2007, Bernat explained how to set up our own domain name using ISC BIND and ISC DHCP. You can’t go wrong with those servers but maybe you prefer something more straightforward. I present here a simpler alternative built on top of dnsmasq which is an integrated DNS and DHCP. Read on &amp;rarr; Using SSH Certificates Jun 6, 2020• Roger Ferrer Ibáñez • ssh Password-based authentication has a number of drawbacks, so many services (such as github) use SSH keys to authenticate. However distributing the keys over several nodes (be virtual machines or single-board computers such as Raspberry Pi) doesn’t scale over the number of nodes and users. Luckily, OpenSSH implementation of SSH supports a certificate-based mechanism. This mechanism may help reducing the complexity of users trusting SSH hosts and hosts trusting SSH users. Read on &amp;rarr; Fortran and modules Mar 10, 2019• Roger Ferrer Ibáñez • Fortran Recently the committee that is preparing the next standard of C++, known as C++20, approved the inclusion of modules. Modules are good™ but they pose some interesting challenges to implementors and users. In this post I will ruminate a bit about what challenges have impacted Fortran. Read on &amp;rarr; Walk-through flang – Part 8 Dec 22, 2018• Roger Ferrer Ibáñez • Compilers, Fortran In the last installment of this series we started to look at the AST and the symbol table by examining the compiler dumps of these two data structures. In this chapter we are going to explore a bit more the AST for the control flow statements. Read on &amp;rarr; Walk-through flang – Part 7 Aug 25, 2018• Roger Ferrer Ibáñez • Compilers, Fortran In previous chapters we saw how the input source was lexed, parsed and semantically analysed and we looked at how the symbols and data types are represented. But we haven&#39;t looked at what happens once the semantic analysis finishes. In this installment we&#39;re going to talk about the AST. Read on &amp;rarr; Walk-through flang – Part 6 Mar 18, 2018• Roger Ferrer Ibáñez • Compilers, Fortran At this point we should have a reasonable picture of how flang parses and generates semantic information. So now it is time to explore with more detail what is actually synthesized and how it can be used later in the compiler. In this chapter we are going to see the symbol table. Read on &amp;rarr; A very simple memory pool in C++11 Nov 19, 2017• Roger Ferrer Ibáñez • Uncategorized I’ve been implementing an algorithm that works on a graph. That algorithm needs to create and destroy lots of nodes and edges to keep track of the algorithm state correctly. The algorithm also needs to be fast in order to be competitive against a similar algorithm that uses sets of stacks instead of graphs. Profiles show that memory allocations are impacting negatively the performance, so maybe a memory pool can help. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 9 Nov 5, 2017• Roger Ferrer Ibáñez • AArch64 In chapter 6 we saw conditional branches and we ended commenting that they can be used to implement higher control constructs. In this chapter we will see a few of them. Read on &amp;rarr; Walk-through flang – Part 5 Oct 7, 2017• Roger Ferrer Ibáñez • Compilers, Fortran In the previous installment of this series we saw how flang parses the statements using an LR(1) algorithm. As the parser recognized the parts of the statements it invokes semantic actions. Today we’re going to talk more about them. Read on &amp;rarr; Walk-through flang – Part 4 Sep 3, 2017• Roger Ferrer Ibáñez • Compilers, Fortran In the last installment we saw how flang splits the input in tokens. Once we have the tokens identified we need to parse them. Read on &amp;rarr; Walk-through flang – Part 3 Jul 29, 2017• Roger Ferrer Ibáñez • Compilers, Fortran In the last chapter we saw how the driver handles the compilation and how it invokes flang1 and flang2. In this chapter we are going to start with flang1. Read on &amp;rarr; Walk-through flang – Part 2 Jun 17, 2017• Roger Ferrer Ibáñez • Compilers, Fortran In the previous installment of this series we saw basically how to install flang and we ran a simple smoke test. In this post we will see a high level overview of what happens when we compile a Fortran program using flang. We will also compare it with what usually happens with clang. Read on &amp;rarr; Walk-through flang – Part 1 Jun 17, 2017• Roger Ferrer Ibáñez • Compilers, Fortran Flang is an open source project to create a Fortran compiler for LLVM. It is based on NVIDIA/PGI Fortran and it has been released under Apache License 2.0. In this series we will do a walk-through the code of this compiler and how it has been integrated in the existing LLVM infrastructure. Read on &amp;rarr; 10 years of Think In Geek Jun 15, 2017• Roger Ferrer Ibáñez • Uncategorized 10 years ago Bernat (brafales) started this blog. This is still his blog though he is a bit busy these days and he cannot publish as much as he wants. All in all, without his initiative this blog would not exist. As would not exist many of the posts I published here since 2012, when Bernat insisted that I should collaborate. I guess his persistence has somehow paid off :) Consider this post a very small celebration of those 10 years. Hopefully we will be able to celebrate many more years. Compilers as a memory error detectors May 31, 2017• Roger Ferrer Ibáñez • Compilers This is a small anecdote of something that happened to me the other day. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 8 May 29, 2017• Roger Ferrer Ibáñez • AArch64 In the last chapter we saw how to call a function. We mentioned a special memory called the stack but we did not delve into it. Let’s see in this chapter how we can use the stack and why it is important in function calls. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 27 Apr 17, 2017• Roger Ferrer Ibáñez • Raspberry Pi We saw in the previous chapter what is the process required to build a program from different compilation units. This process happened before we obtained the final program. The question is, can this process happen when the program runs? This is, is it possible to dynamically link a program? Read on &amp;rarr; Whose is this optimization? Apr 2, 2017• Roger Ferrer Ibáñez • Compilers Today we will toy around a very simple optimization in clang and discuss a bit about separation of concerns when optimizing code. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 7 Mar 19, 2017• Roger Ferrer Ibáñez • AArch64 In the previous installment of this series we saw how to alter the sequencing of our programs. Today we will see how we can reuse instructions by means of branches. Let&#39;s talk about functions. Read on &amp;rarr; Compilation of array expressions in Fortran Feb 25, 2017• Roger Ferrer Ibáñez • Fortran As I stated in my previous post, Fortran 90 improved the array capabilities of Fortran. Today we will discuss what are the challenges when compiling array expressions. Read on &amp;rarr; Introduction to the gfortran array descriptor Jan 14, 2017• Roger Ferrer Ibáñez • Compilers, Fortran With the approval of Fortran 90, its array capabilities were largely improved. While still far from languages like APL, the extra functionality required a rethinking of the concept array in Fortran. This led to the need for array descriptors in the language. Read on &amp;rarr; How (not) to write a C++ front end – Part 3 Dec 3, 2016• Roger Ferrer Ibáñez • Compilers In the previous installment we talked about the parsing technology we used, which looks like the canonical academic approach to parsing. In this chapter we will see some dificulties we encountered along the years. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 6 Nov 27, 2016• Roger Ferrer Ibáñez • AArch64 So far we know how to do some computations and access memory. Today we will learn how to alter the control flow of our program. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 5 Nov 13, 2016• Roger Ferrer Ibáñez • AArch64 In this chapter we will see how we can access the memory in AArch64. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 26 Oct 30, 2016• Roger Ferrer Ibáñez • Raspberry Pi In this chapter we will talk about a fascinating step that is required to create a program, even when using assembler. Today we will talk about linking. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 4 Oct 23, 2016• Roger Ferrer Ibáñez • AArch64 In this chapter we will see some instructions that will allow us to compute things. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 3 Oct 23, 2016• Roger Ferrer Ibáñez • AArch64 In the last chapter we saw that instructions may have register operands and immediate operands. We also mentioned that mixing 32-bit and 64-bit register was not allowed. Today we will talk a bit more about register operands. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 2 Oct 8, 2016• Roger Ferrer Ibáñez • AArch64 In the first installment of this series we did a very first simple program. In this chapter we will continue learning a bit more about AArch64. Read on &amp;rarr; How (not) to write a C++ front end – Part 2 Oct 8, 2016• Roger Ferrer Ibáñez • Compilers In the previous installment I gave some context about the existence of Mercurium as a tool. In this chapter we will start digging into the parsing technology used. Read on &amp;rarr; How (not) to write a C++ front end – Part 1 Oct 8, 2016• Roger Ferrer Ibáñez • Compilers As part of the work I did in my previous employer, we had to develop a C++ front end. This is never an easy task so I will use this series to share some experiences while developing it. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 1 Oct 8, 2016• Roger Ferrer Ibáñez • AArch64 AArch64 is a new 64 bit mode that is part of the ARMv8 architecture presented in 2011 by ARM. It has been progressively been deployed in smartphones and servers. So I think it is a good moment to learn a bit more about the assembler of this architecture. Read on &amp;rarr; A tiny GCC front end – Part 11 Sep 5, 2016• Roger Ferrer Ibáñez • Compilers, GCC Our tiny language features a few types: int, float, bool, string and arrays of those types. We can even declare new type names based on other types but it still missing a record type. Today we will address this. Read on &amp;rarr; A tiny GCC front end – Part 10 Sep 4, 2016• Roger Ferrer Ibáñez • Compilers, GCC Today we will add a relatively simple feature that will be very useful for a future extension: type declarations. Read on &amp;rarr; A tiny GCC front end – Part 9 Jan 31, 2016• Roger Ferrer Ibáñez • Compilers, GCC Today we will do something relatively easy: let&#39;s add a way to declare boolean variables and express boolean literals. Read on &amp;rarr; A tiny GCC front end – Part 8 Jan 30, 2016• Roger Ferrer Ibáñez • Compilers, GCC Now that we have the basic language set implemented we can consider adding new features to it. Today we will add arrays. Read on &amp;rarr; A tiny GCC front end – Part 7 Jan 19, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny In this part we will complete the missing statements from part 6 and finish our front end. Read on &amp;rarr; A tiny GCC front end – Part 6 Jan 17, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny In part 5 we described the objects that we will need to semantically analyze a tiny program. In current part we will extend the parser of part 4 to do the semantic analysis and create the GENERIC trees. Read on &amp;rarr; A tiny GCC front end – Part 5 Jan 16, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny In the last installment of this series we saw how to verify that the sequence of tokens of the input is syntactically valid. Today we will see what we need to give it meaning. Read on &amp;rarr; A tiny GCC front end – Part 4 Jan 10, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny Now that we have a stream of tokens we can start performing syntactic analysis. Read on &amp;rarr; A tiny GCC front end – Part 3 Jan 8, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny Now that the minimal infrastructure is already set, we can start with the implementation of our tiny front end. Today we will talk about the lexer. Read on &amp;rarr; A tiny GCC front end – Part 2 Jan 6, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny The previous installment of this series was all about the syntax and the semantics of the tiny language. In this chapter we will start implementing a front end for tiny in GCC. The journey will be long but rewarding. Let&#39;s get started. Read on &amp;rarr; A tiny GCC front end – Part 1 Jan 5, 2016• Roger Ferrer Ibáñez • Compilers, GCC • compilers, frontend, gcc, tiny In this series we will see the process of adding a new front end for a very simple language in GCC. If you, like me, marvel at the magic of compilers then these posts may be for you. Read on &amp;rarr; Toying with GCC JIT – Part 3 Nov 20, 2015• Roger Ferrer Ibáñez • Compilers In the last two parts of this series we&#39;ve seen how to use GCC JIT and how to apply it to a simple regular expression matcher. But an open question remains, has it been worth the effort? This part will try to figure it out. Read on &amp;rarr; Toying with GCC JIT – Part 2 Nov 18, 2015• Roger Ferrer Ibáñez • Compilers One of the quintessential UNIX tools is the grep tool. The global regular expression print is a tool that prints lines of text file that match a given regular expression. In this post we will apply JIT compilation to a very simple regular expression matcher by Rob Pike. Read on &amp;rarr; Toying with GCC JIT – Part 1 Nov 14, 2015• Roger Ferrer Ibáñez • Compilers A just-in-time (JIT) compiler is a compiler that in contrast to the usual compilers is not run ahead-of-time, i.e. before running the actual program, but during the program itself. Read on &amp;rarr; A simple plugin for GCC – Part 3 Aug 17, 2015• Roger Ferrer Ibáñez • Compilers In the last chapter, we extended our plugin so it was possible to visualize the control flow graph of a function. In this chapter we will reach our goal to warn unused results of function calls. Read on &amp;rarr; A simple plugin for GCC – Part 2 Aug 16, 2015• Roger Ferrer Ibáñez • Compilers In the last post we set up everything in order to write a GCC plugin. Before we can go on we need to understand a bit how GCC compiles your files. Read on &amp;rarr; A simple plugin for GCC – Part 1 Aug 16, 2015• Roger Ferrer Ibáñez • Compilers GCC&#39;s C and C++ compilers provide several extensions to address several programming needs not covered in the standards. One of these is the warn_unused_result attribute. This attribute warns us that we are discarding the result of a function. Unfortunately, for C++ it does not always work as expected. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 25 Jul 4, 2015• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, pi, raspberry In chapter 13 we saw VFPv2 and the fact that it allows vectorial operations on floating-point numbers. You may be wondering if such a similar feature exists for integers. The answer is yes although in a more limited way. Read on &amp;rarr; When an array is not an array Feb 26, 2015• Roger Ferrer Ibáñez • Uncategorized • arrays, c language, language, standard c, standardc The C programming language comes with its own set of warts if we closely examine its syntax and semantics. One of the oddities that puzzles most people is the fact that there are no parameters of array types in C. This fact, though, does not prevent one using the array syntax in a parameter. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 24 Jan 9, 2015• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, raspberry Today we will continue with nested functions. Read on &amp;rarr; Read DVDs with bogus permissions in Ubuntu Jan 3, 2015• Roger Ferrer Ibáñez • Linux • debian, fixes, opensource, packages, ubuntu What if your DVD recorder sets bogus permissions to your DVDs? Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 23 Jan 2, 2015• Roger Ferrer Ibáñez • Raspberry Pi Today we will see what happens when we nest a function inside another. It seems a harmless thing to do but it happens to come with its own dose of interesting details. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 22 Dec 20, 2014• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler Several times in previous chapters we have talked about ARM as an architecture that has several features aimed at embedding systems. In embedded systems memory is scarce and expensive, so designs that help reduce the memory footprint are very welcome. Today we will see another of these features: the Thumb instruction set. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 21 Aug 23, 2014• Roger Ferrer Ibáñez • Raspberry Pi We already know that ARM is a 32-bit architecture: general purpose registers are 32-bit wide and addresses in memory are 32-bit numbers. The natural integer size for an architecture is usually called a word and in ARM is obviously 32-bit integers. Sometimes, though, we need to deal with subword data: integers of size smaller than 32 bits. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 20 Aug 20, 2014• Roger Ferrer Ibáñez • Raspberry Pi Today we will see how to make indirect calls. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 19 May 24, 2014• Roger Ferrer Ibáñez • Raspberry Pi So far our small assembler programs have output messages using printf and some of them have read input using scanf. These two functions are implemented in the C library, so they are more or less supported in any environment supporting the C language. But how does a program actually communicate with the world? Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 18 May 11, 2014• Roger Ferrer Ibáñez • Raspberry Pi In this chapter we will delve a bit more into the stack. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 17 Nov 20, 2013• Roger Ferrer Ibáñez • Raspberry Pi In chapter 10 we saw the basics to call a function. In this chapter we will cover more topics related to functions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 16 Aug 23, 2013• Roger Ferrer Ibáñez • Raspberry Pi We saw in chapters 6 and 12 several control structures but we left out a usual one: the switch also known as select/case. In this chapter we will see how we can implement it in ARM assembler. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 15 Aug 11, 2013• Roger Ferrer Ibáñez • Raspberry Pi It may be suprising, but the ARMv6 architecture does not provide an integer division instruction while it does have a floating point instruction in VFPv2. In this chapter we will see usual ways to workaround this limitation with different techniques that can be used in specific scenarios involving divisions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 14 May 12, 2013• Roger Ferrer Ibáñez • Raspberry Pi In chapter 13 we saw the basic elements of VFPv2, the floating point subarchitecture of ARMv6. In this chapter we will implement a floating point matrix multiply using VFPv2. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 13 May 12, 2013• Roger Ferrer Ibáñez • Raspberry Pi So far, all examples have dealt with integer values. But processors would be rather limited if they were only able to work with integer values. Fortunately they can work with floating point numbers. In this chapter we will see how we can use the floating point facilities of our Raspberry Pi. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 12 Mar 28, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, pi, raspberry We saw in chapter 6 some simple schemes to implement usual structured programming constructs like if-then-else and loops. In this chapter we will revisit these constructs and exploit a feature of the ARM instruction set that we have not learnt yet. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 11 Mar 16, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, branches, function, function call, functions, pi, predication, raspberry Several times, in earlier chapters, I stated that the ARM architecture was designed with the embedded world in mind. Although the cost of the memory is everyday lower, it still may account as an important part of the budget of an embedded system. The ARM instruction set has several features meant to reduce the impact of code size. One of the features which helps in such approach is predication. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 10 Feb 7, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, function, function call, functions, pi, raspberry, stack In chapter 9 we were introduced to functions and we saw that they have to follow a number of conventions in order to play nice with other functions. We also briefly mentioned the stack, as an area of memory owned solely by the function. In this chapter we will go in depth with the stack and why it is important for functions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 9 Feb 2, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, function, function call, functions, pi, raspberry In previous chapters we learnt the foundations of ARM assembler: registers, some arithmetic operations, loads and stores and branches. Now it is time to put everything together and add another level of abstraction to our assembler skills: functions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 8 Jan 27, 2013• Roger Ferrer Ibáñez • Raspberry Pi • addresses, arm, assembler, indexing modes, pi, postindex, preindex, raspberry In the previous chapter we saw that the second operand of most arithmetic instructions can use a shift operator which allows us to shift and rotate bits. In this chapter we will continue learning the available indexing modes of ARM instructions. This time we will focus on load and store instructions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 7 Jan 26, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, indexing modes, pi, raspberry ARM architecture has been for long targeted at embedded systems. Embedded systems usually end being used in massively manufactured products (dishwashers, mobile phones, TV sets, etc). In this context margins are very tight so a designer will always try to spare as much components as possible (a cent saved in hundreds of thousands or even millions of appliances may pay off). One relatively expensive component is memory although every day memory is less and less expensive. Anyway, in constrained memory environments being able to save memory is good and ARM instruction set was designed with this goal in mind. It will take us several chapters to learn all of these techniques, today we will start with one feature usually named shifted operand. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 6 Jan 20, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, control structures, pi, raspberry Control structures In the previous chapter we learnt branch instructions. They are really powerful tools because they allow us to express control structures. Structured programming is an important milestone in better computing engineering (a foundational one, but nonetheless an important one). So being able to map usual structured programming constructs in assembler, in our processor, is a Good Thing™. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 5 Jan 19, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, branches, pi, raspberry Branching Until now our small assembler programs execute one instruction after the other. If our ARM processor were only able to run this way it would be of limited use. It could not react to existing conditions which may require different sequences of instructions. This is the purpose of the branch instructions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 4 Jan 12, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, debugger, gdb, pi, raspberry As we advance learning the foundations of ARM assembler, our examples will become longer. Since it is easy to make mistakes, I think it is worth learning how to use GNU Debugger gdb to debug assembler. If you develop C/C++ in Linux and never used gdb, shame on you. If you know gdb this small chapter will explain you how to debug assembler directly. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 3 Jan 11, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, load, pi, raspberry, store We saw in chapter 1 and chapter 2 that we can move values to registers (using mov instruction) and add two registers (using add instruction). If our processor were only able to work on registers it would be rather limited. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 2 Jan 10, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, pi, raspberry Registers At its core, a processor in a computer is nothing but a powerful calculator. Calculations can only be carried using values stored in very tiny memories called registers. The ARM processor in a Raspberry Pi has 16 integer registers and 32 floating point registers. A processor uses these registers to perform integer computations and floating point computations, respectively. We will put floating registers aside for now and eventually we will get back to them in a future installment. Let’s focus on the integer registers. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 1 Jan 9, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, pi, raspberry In my opinion, it is much more beneficial learning a high level language than a specific architecture assembler. But I fancied learning some ARM assembler just for fun since I know some 386 assembler. The idea is not to become a master but understand some of the details of what happens underneath. Read on &amp;rarr; Common linking issues in C++ Aug 8, 2012• Roger Ferrer Ibáñez • Uncategorized Introduction C++ is a language derived from C, so in essence all problems at link time boil down at declaring stuff but not defining it. Declaring something in C++ means bringing the entity into existence in the program, so it can be used after the declaration point. Defining something means giving a complete description of the entity itself. You can declare a class or a function, and it means this class and this function do exist. But to completely describe a class and a function you have to define them. A class definition provides a list of base classes of that class, a list of members (data members and member functions) of that class, etc. A function definition provides the executable code of that function. All definitions are declarations but not all declarations are definitions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Defines variable &#39;x&#39; int x; // Declares variable &#39;y&#39; extern int y; // Declares class &#39;A&#39; struct A; // Declares function &#39;f(int)&#39; void f(int); // Defines class &#39;A&#39; struct A { // Declares member function &#39;A::g(float)&#39; void g(float); // Defines member function &#39;A::h(char)&#39; void h(char) { // Code } // Defines data member &#39;A::x&#39; int x; // Declares static data member &#39;A::y&#39; static int y; }; // Defines function&#39;f(int)&#39; void f(int) { // Code } // Defines member function &#39;A::g(float)&#39; void A::g(float) { // Code } // Defines static data member &#39;A::y&#39; int A::y; C++, in contrast to C, strongly sticks to the One Definition Rule which states that entities can be defined at most once in an entire program. Of course this may not be completely true depending your own the definition of &quot;entity&quot;: template functions when instantiated by the compiler can be defined more than once in the program, and some magic happens so this does not become a problem. Anyway, C++ brings its own set of linking issues which may fool even the most experienced C++ developer. Static data members are only declared inside the class specifier Some might argue that this is one of the most common source of linking issues when using C++. Truth be told, static data members are just global variables in disguise so most people will avoid them. However, there are cases where a static data member may come in handy, for instance when implementing the singleton pattern. The problem lies that, although usual (nonstatic) data members are defined when they are declared inside a class (like in line 23 of the example above), static data members are only declared. Thus in line 26 of the example above A::y is only being declared. Its actual definition is given in line 42. The actual definition of a static data member will go in the implementation file (usually a .cpp or .cc file). So the usual case goes like this: you realize you need a static data member. You add it to the class. Your code compiles fine but does not link. In fact &#39;A::y&#39;, the static data member you just added is undefined? How can this be? Now you know the reason. What is the reason this issue is hit so many times? Well, there are three reasons. A historical one, where early versions of C++ compilers allowed this. A quirk in the C++ language itself where const integral and enumerator static data members can be declared and initialized in the class itself (thus defining them as well). And finally, a linguistic issue, since in Java and C# static fields are declared like any other fields plus a static specifier. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // -- Header file class MySingleton { public: static MySingleton&amp;amp; getInstance() { if (singleton_ == 0) singleton_ = new MySingleton; return *singleton_; } private: // Usual private constructor MySingleton() { } // Declaration static MySingleton *singleton_; }; // -- Implementation file // Definition MySingleton* MySingleton::singleton_ = 0; Not all headers are created equal The usual myth is that C++ is a superset of C. Well, it looks like as a superset of C but they are actually two different languages. That said, they share so many thinks that interfacing C++ and C is pretty straightforward, in particular when the former must call the latter (the opposite may be a bit more challenging). Thus, it is not unsual to see that a C++ program #includes C header files. Chances are that the headers of your operating system will be in C. Being able to #include a C header and using the entities declared in it is one of the strengths of C++. And this is the source of our second problem. Remember that in C++ functions may be overloaded. This means that we can use the same name when declaring two functions in the same scope as long as they have different enough parameter types. 1 2 3 4 5 6 7 // Declaration of &#39;f(int)&#39; void f(int); // Declaration of &#39;f(float)&#39; void f(float); // Redeclaration of &#39;f(int)&#39; since, in a parameter, &#39;const int&#39; cannot // be distinguished from &#39;int&#39; void f(const int); It may be non obvious, but we cannot give these two functions declared above the same f name. So the compiler crafts an artificial name for f(int) and f(float) (this is called a decorated name or a mangled name). For instance they could be f_1_int and f_1_float (here 1 would mean the number of parameters). The C++ compiler will internally use these names when generating code and the lower levels will just see two diferent names. But overloading cannot be applied to C. Thus we run into a problem here. If we #include C headers, the names of these functions cannot be overloaded thus a C compiler will generated code using the (undecorated) name of the function. If our C++ compiler always uses a decorated name, there will be an unresolved symbol. The C++ compiler cannot tell if this is C or C++. Can it? Good news, it can. You can define the linkage of declarations in the code. By default linkage is C++ so overload works as described above. When you want to #include a C header, you will have to tell the C++ compiler that the linkage of the declarations is C, not C++. Most of the time you will find these lines in the beginning of a C header intended to be used from C++. 1 2 3 4 5 6 7 8 9 10 11 12 13 // Remember this is a C header so protect ourselves when this is compiled using C #ifdef __cplusplus // This &#39;extern &quot;C&quot;&#39; syntax is only valid in C++, not in C. extern &quot;C&quot; { // From now everything has C linkage. #endif /* Library declarations in C */ #ifdef __cplusplus // Close the brace opened above } #endif Virtual member functions and virtual tables Finally one of the, in my opinion, most confusing link errors when using a C++ compilers: virtual table unresolved references. Virtual member functions are, in C++ parlance, polymorphic methods of other programming languages (like Java). Virtual member functions can be overridden by derived classes (descendant classes) thus when called, they must be dispatched dinamically. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct A { virtual void vmf(float*); virtual void vmf2(float*); }; struct B : A { virtual void vmf(float*); virtual void vmf3(float*); }; virtual B::vmf(float*) { // Code } void g(A* pa, float *pfl) { // Dynamic dispatch // we don&#39;t really know if A::vmf or B::vmf will be called pa-&amp;gt;vmf(pfl); // Static call to A::vmf since we qualified the function being called pa-&amp;gt;A::vmf(pfl); B b; // Static call to B::vmf, no doubts here since the dynamic type (in memory) // of &#39;b&#39; and its declared type must be the same b.vmf(pfl); A&amp;amp; ra(*pa); // Dynamic dispatch again ra.vmf(pfl); } Dynamic dispatch is implemented using a virtual method table (or vtable). Every class with virtual methods (called a dynamic class) has a vtable. This vtable is a sequence of addresses to member functions. Every virtual member function is assigned an index in this table and the addresses points to the function implementing the virtual member function for that class. For instance class A above has two member functions vmf and vmf2. The vtable of A, then will have two entries, 0 and 1, and will point to the functions A::vmf and A::vmf2 respectively. The vtable of B will have three entries, 0, 1, 2, that will point to functions B::vmf, A::vmf2 and B::vmf3 respectively. Every object of a dynamic class has a hidden data member (called the virtual pointer) that points to the vtable of its class. When C++ specifies that a call goes through dynamic dispatch (in C++ parlance, a call to the ultimate overrider), we do not call directly any function but instead, through this hidden data member, we reach the vtable and using the index of the virtual member function being called, we retrieve the entry containing the addresses to the real function. Then this addresses is used in an indirect call. Since both the virtual table and the virtual pointer are hidden from the eyes of the developer, sometimes errors in our code may cause link errors. The compiler does not emit a vtable This may not apply to all C++ compilers, but usually a C++ compiler only emits a vtable when it finds a definition of a virtual member function. Note that virtual member function definitions for a given class may be scattered in several files. Magic happens again so more than one definition of the vtable of a given class in several files does not become a problem at link time. But, what if you forget to define all virtual functions? This may look contrived but in my experience this may happen by accident. The problem lies on the error at link time, which is really confusing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct A { int x_; A(int x) : x_(x) { } // We forget to define A::foo virtual void foo(); }; void quux(A* a) { // Dynamic dispatch a-&amp;gt;foo(); } int main(int argc, char * argv[]) { A a(3); quux(&amp;amp;a); } If you compile and link this with g++ (I use -g since it improves link error messages by using the debugging information). $ g++ -o prova test.cc -g /tmp/ccl71r2A.o: In function `A&#39;: test.cc:4: undefined reference to `vtable for A&#39; collect2: ld returned 1 exit status But the line 4 is the constructor. You see now how confusing this message is, don&#39;t you? What is going on? Well, everything makes sense if we remember that hidden data member I mentioned above, the virtual pointer. As a data member of a class it must be initialized in the constructor. It is initialized with the address of the virtual table of A. But the virtual table of A was not emitted since we forgot to define all virtual member functions. Thus, unresolved reference for the virtual table. Missing virtual member functions in base classes Remember that the vtable contains entries for all the virtual member functions of the base tables. The vtable is statically initialized (this is, the compiler &quot;hardcodes&quot; in the generated code, in the data section) the addresses of each entry. What if we forget to define a virtual member function of a base class? Consider this example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct A { int x_; A(int x) : x_(x) { } virtual void foo(); // We forget to define A::foo2 virtual void foo2(); }; void A::foo() { // Definition of A::foo } struct B : A { B(int x) : A(x) { } virtual void foo() { // Definition of B::foo } }; void quux(A* a) { a-&amp;gt;foo(); } int main(int argc, char * argv[]) { B b(3); quux(&amp;amp;b); } If we compile and link with g++ we get /tmp/cc4t9NG3.o:(.rodata._ZTV1B[vtable for B]+0xc): undefined reference to `A::foo2()&#39; /tmp/cc4t9NG3.o:(.rodata._ZTV1A[vtable for A]+0xc): undefined reference to `A::foo2()&#39; collect2: ld returned 1 exit status This happens because vtables of A and B refer to A::foo2, but we forgot to define it. Fortunately, now the error message is easier to grasp: some function is missing. Obviously, many more link errors caused by C++ exist, but I think the ones shown here are quite common and the error messages related to them are quite confusing. Crazy stuff in C++ (1) Jul 29, 2012• Roger Ferrer Ibáñez • Uncategorized • classes, cplusplus, functions, specializations, templates Introduction C++ is a controversial language: you love it or you hate it. As always, knowing better about something allows one to make better arguments for or against that thing. This is what this series is about. Here I’ll explain some of the less known (except for C++ expert programmers, of course) features of C++. Let’s start with templates, which account for such a huge part of the language. Templates Everyone knows that C++ has templates. Templates is an implementation of the «I have an algorithm that can be used with many different types» idea. This idea is called generic programming and is a pretty powerful one. This is why it is present in almost all modern languages. Back to C++. C++ defines two kinds of templates: classes templates and function templates. Class templates define an infinite set of classes while function templates define an infinite set of functions. The elements of these sets of classes or functions are called specializations. Every template has a template-name which will be used to name a specific specialization. Template declarations Consider these two declarations 1 2 template &amp;lt;typename T&amp;gt; struct my_list { ... } 1 2 template &amp;lt;typename T&amp;gt; void max(T a, T b) { return a &amp;gt; b ? a : b; } These are template declarations. The first one declares a class template and its template-name is my_list, the second one defines a function template and its template-name is max. A template declaration is just a declaration preceded with something without an official name that starts with template &amp;lt;…&amp;gt;, I will call it the template header (but note that this name is not blessed by the C++ standard at all, it just makes sense to me call it like this). The template header defines what are the parameters of the template class. These are called the template parameters. A type-template parameter, like that T shown above, is a “type variable”. This is the most usual template parameter as it allows to parameterize the declaration over one or more type variables. C++, though, has two more kinds of template parameters: nontype-template parameters and (the funny named) template-template parameter. A nontype-template parameter allows us to parameterize the declaration over a (compile-time) constant integer value. Here “integer value” is a very broad term: of course it includes all integers, but also enum values (enumerators) and addresses of (statically allocated) variables and functions. A template-template parameter allows us to parameterize a declaration over another class template with appropiate template parameters. 1 2 template &amp;lt;typename T, int N&amp;gt; // N is a nontype-template parameter struct my_fixed_array { }; 1 2 template &amp;lt;template &amp;lt;typename T&amp;gt; MyContainer&amp;gt; // MyContainer is a template-template parameter struct adaptor { }; Specializations I said above that a class template or function template defines an infinite set of classes or function and that each element of that set was called a specialization. There is a specialization for every possible value that a template parameter can have. Such values are not bounded thus there is an infinite number of specializations (well, we could argue that constant integer values are finite in the language, but types are clearly not finite). We give value to template parameters of a template by means of template arguments. These template arguments always appear in what is called a template-id. A template-id is just the template-name followed by a list of template-arguments enclosed in &amp;lt; and &amp;gt;. 1 2 my_list&amp;lt;int&amp;gt; l;// Here T has value int, we will write it as T ← int max&amp;lt;float&amp;gt;(3.4f, 5.6f); // T ← float Primary template and partial specializations When we first declare a class template or a function template, such declaration defines the primary template. 1 2 template &amp;lt;typename T&amp;gt; struct my_list { ... }; 1 2 template &amp;lt;typename T&amp;gt; void swap(T&amp;amp; a, T&amp;amp; b); Class templates (but not function templates!) can have an extra set of template declarations called partial specializations. A partial specialization looks like a normal class template declaration but the template-name is now a template-id where the template-arguments partially specialize the given template parameters. 1 2 3 4 5 6 7 8 9 10 11 12 // 1) Partial specialization for &quot;pointer to (any) P&quot; type template &amp;lt;typename P&amp;gt; struct my_list&amp;lt;P*&amp;gt; { }; // 2) Partial specialization for &quot;array of (any) Size of (any) Element&quot; template &amp;lt;typename Element, int Size&amp;gt; struct my_list&amp;lt;Element[Size]&amp;gt; { }; // 3) Partial specialization for &quot;pointer to function with two parameters // Arg1 and Arg2 returning Ret&quot; template &amp;lt;typename Ret, typename Arg1, typename Arg2&amp;gt; struct my_list&amp;lt;Ret (*)(Arg1, Arg2)&amp;gt;; A C++ compiler will always pick the partial specialization (if any) that is “closer” to the one requested in the template arguments. If no partial specialization matches, the primary template is chosen instead. The exact algorithm is not important here. 1 2 3 4 5 6 7 8 9 10 my_list&amp;lt;int&amp;gt; l0; // will pick the primary template T ← int my_list&amp;lt;int*&amp;gt; l1; // will pick partial specialization 1) // where P ← int (note that respect to the primary template this is T ← int*) my_list&amp;lt;int[10]&amp;gt; l2; // will pick partial specialization 2) // where Element ← int and Size ← 10 my_list&amp;lt;int (*)(float, double)&amp;gt; l3; // will pick partial specialization 3) // where Ret ← int, Arg1 ← float and Arg2 ← double I think this is enough for today regarding C++ templates. More craziness to come. Stay tuned.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://thinkingeek.com/author/rferrer/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Think In Geek" href="https://thinkingeek.com/feed.xml">

  

  
  <meta property="og:title" content="Posts by Roger Ferrer Ibáñez">
  <meta property="og:site_name" content="Think In Geek">
  <meta property="og:url" content="https://thinkingeek.com/author/rferrer/">
  <meta property="og:description" content="Fun with vectors in the Raspberry Pi 1 - Part 2 Jun 25, 2021• Roger Ferrer Ibáñez • vectors, raspberry pi 1, llvm, compilers, arm Ok so in the previous installment we discussed a bit how to generate code using the vector feature of the CPU of the Raspberry Pi 1. Let’s start hacking LLVM. Read on &amp;rarr; Fun with vectors in the Raspberry Pi 1 - Part 1 Jun 25, 2021• Roger Ferrer Ibáñez • vectors, raspberry pi 1, llvm, compilers, arm Long ago, we saw that the Raspberry Pi 1 has vector computation capabilities.. However to the best of my knowledge no compiler attempted to exploit the vector capability in general. I think we are going to have some fun in trying to fix this. Read on &amp;rarr; RAII, locks and clang-tidy Mar 1, 2021• Roger Ferrer Ibáñez • c++, raii, clang-tidy, locks A colleague of mine spent some time chasing a bug in a C++ library related to concurrency. At the end it all boiled down to a silly declaration that wasn’t one. Read on &amp;rarr; Process-wide information and Linux key management Nov 22, 2020• Roger Ferrer Ibáñez • linux, libraries, programming I believe this is not a very common scenario, but sometimes one has to develop libraries whose scope is the whole process. In such a situation, we may need to identify if a process has already loaded another copy of the library. Read on &amp;rarr; Forgotten memories (2) Jun 20, 2020• Roger Ferrer Ibáñez • compilers, llvm, risc-v So in the first part of this experiment we saw a simple strategy to spill general-purpose registers into floating-point registers implemented in the RISC-V backend of LLVM. In this chapter, let’s see the results and some other interesting facts learnt during the process. Read on &amp;rarr; Forgotten memories (1) Jun 20, 2020• Roger Ferrer Ibáñez • compilers, llvm, risc-v Most compiler infrastructures that target register machines do it by using the concept of virtual registers. In their intermediate representations instructions use virtual registers to represent their operands. Because hardware is finite, these virtual registers must be mapped to physical registers at some point. The compiler does this in a process called register allocation. Being physical registers finite, it may happen that not all the virtual registers used by the program can be held in physical registers at the same time. When this happens, the compiler must emit spill code. Spill code stores a value in a memory (spill) and loads it later, often close to the point of use (reload). The memory used for spill code is commonly the function stack. However nothing prevents us from using other kinds of “memories” as long as we can guarantee that nobody is going to use them. This is exactly the kind of experiment we will do today: we’re going to spill general-purpose registers into floating-point registers. Read on &amp;rarr; Create your own local domain and DHCP with dnsmasq Jun 6, 2020• Roger Ferrer Ibáñez • dns, dhcp Back in 2007, Bernat explained how to set up our own domain name using ISC BIND and ISC DHCP. You can’t go wrong with those servers but maybe you prefer something more straightforward. I present here a simpler alternative built on top of dnsmasq which is an integrated DNS and DHCP. Read on &amp;rarr; Using SSH Certificates Jun 6, 2020• Roger Ferrer Ibáñez • ssh Password-based authentication has a number of drawbacks, so many services (such as github) use SSH keys to authenticate. However distributing the keys over several nodes (be virtual machines or single-board computers such as Raspberry Pi) doesn’t scale over the number of nodes and users. Luckily, OpenSSH implementation of SSH supports a certificate-based mechanism. This mechanism may help reducing the complexity of users trusting SSH hosts and hosts trusting SSH users. Read on &amp;rarr; Fortran and modules Mar 10, 2019• Roger Ferrer Ibáñez • Fortran Recently the committee that is preparing the next standard of C++, known as C++20, approved the inclusion of modules. Modules are good™ but they pose some interesting challenges to implementors and users. In this post I will ruminate a bit about what challenges have impacted Fortran. Read on &amp;rarr; Walk-through flang – Part 8 Dec 22, 2018• Roger Ferrer Ibáñez • Compilers, Fortran In the last installment of this series we started to look at the AST and the symbol table by examining the compiler dumps of these two data structures. In this chapter we are going to explore a bit more the AST for the control flow statements. Read on &amp;rarr; Walk-through flang – Part 7 Aug 25, 2018• Roger Ferrer Ibáñez • Compilers, Fortran In previous chapters we saw how the input source was lexed, parsed and semantically analysed and we looked at how the symbols and data types are represented. But we haven&#39;t looked at what happens once the semantic analysis finishes. In this installment we&#39;re going to talk about the AST. Read on &amp;rarr; Walk-through flang – Part 6 Mar 18, 2018• Roger Ferrer Ibáñez • Compilers, Fortran At this point we should have a reasonable picture of how flang parses and generates semantic information. So now it is time to explore with more detail what is actually synthesized and how it can be used later in the compiler. In this chapter we are going to see the symbol table. Read on &amp;rarr; A very simple memory pool in C++11 Nov 19, 2017• Roger Ferrer Ibáñez • Uncategorized I’ve been implementing an algorithm that works on a graph. That algorithm needs to create and destroy lots of nodes and edges to keep track of the algorithm state correctly. The algorithm also needs to be fast in order to be competitive against a similar algorithm that uses sets of stacks instead of graphs. Profiles show that memory allocations are impacting negatively the performance, so maybe a memory pool can help. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 9 Nov 5, 2017• Roger Ferrer Ibáñez • AArch64 In chapter 6 we saw conditional branches and we ended commenting that they can be used to implement higher control constructs. In this chapter we will see a few of them. Read on &amp;rarr; Walk-through flang – Part 5 Oct 7, 2017• Roger Ferrer Ibáñez • Compilers, Fortran In the previous installment of this series we saw how flang parses the statements using an LR(1) algorithm. As the parser recognized the parts of the statements it invokes semantic actions. Today we’re going to talk more about them. Read on &amp;rarr; Walk-through flang – Part 4 Sep 3, 2017• Roger Ferrer Ibáñez • Compilers, Fortran In the last installment we saw how flang splits the input in tokens. Once we have the tokens identified we need to parse them. Read on &amp;rarr; Walk-through flang – Part 3 Jul 29, 2017• Roger Ferrer Ibáñez • Compilers, Fortran In the last chapter we saw how the driver handles the compilation and how it invokes flang1 and flang2. In this chapter we are going to start with flang1. Read on &amp;rarr; Walk-through flang – Part 2 Jun 17, 2017• Roger Ferrer Ibáñez • Compilers, Fortran In the previous installment of this series we saw basically how to install flang and we ran a simple smoke test. In this post we will see a high level overview of what happens when we compile a Fortran program using flang. We will also compare it with what usually happens with clang. Read on &amp;rarr; Walk-through flang – Part 1 Jun 17, 2017• Roger Ferrer Ibáñez • Compilers, Fortran Flang is an open source project to create a Fortran compiler for LLVM. It is based on NVIDIA/PGI Fortran and it has been released under Apache License 2.0. In this series we will do a walk-through the code of this compiler and how it has been integrated in the existing LLVM infrastructure. Read on &amp;rarr; 10 years of Think In Geek Jun 15, 2017• Roger Ferrer Ibáñez • Uncategorized 10 years ago Bernat (brafales) started this blog. This is still his blog though he is a bit busy these days and he cannot publish as much as he wants. All in all, without his initiative this blog would not exist. As would not exist many of the posts I published here since 2012, when Bernat insisted that I should collaborate. I guess his persistence has somehow paid off :) Consider this post a very small celebration of those 10 years. Hopefully we will be able to celebrate many more years. Compilers as a memory error detectors May 31, 2017• Roger Ferrer Ibáñez • Compilers This is a small anecdote of something that happened to me the other day. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 8 May 29, 2017• Roger Ferrer Ibáñez • AArch64 In the last chapter we saw how to call a function. We mentioned a special memory called the stack but we did not delve into it. Let’s see in this chapter how we can use the stack and why it is important in function calls. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 27 Apr 17, 2017• Roger Ferrer Ibáñez • Raspberry Pi We saw in the previous chapter what is the process required to build a program from different compilation units. This process happened before we obtained the final program. The question is, can this process happen when the program runs? This is, is it possible to dynamically link a program? Read on &amp;rarr; Whose is this optimization? Apr 2, 2017• Roger Ferrer Ibáñez • Compilers Today we will toy around a very simple optimization in clang and discuss a bit about separation of concerns when optimizing code. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 7 Mar 19, 2017• Roger Ferrer Ibáñez • AArch64 In the previous installment of this series we saw how to alter the sequencing of our programs. Today we will see how we can reuse instructions by means of branches. Let&#39;s talk about functions. Read on &amp;rarr; Compilation of array expressions in Fortran Feb 25, 2017• Roger Ferrer Ibáñez • Fortran As I stated in my previous post, Fortran 90 improved the array capabilities of Fortran. Today we will discuss what are the challenges when compiling array expressions. Read on &amp;rarr; Introduction to the gfortran array descriptor Jan 14, 2017• Roger Ferrer Ibáñez • Compilers, Fortran With the approval of Fortran 90, its array capabilities were largely improved. While still far from languages like APL, the extra functionality required a rethinking of the concept array in Fortran. This led to the need for array descriptors in the language. Read on &amp;rarr; How (not) to write a C++ front end – Part 3 Dec 3, 2016• Roger Ferrer Ibáñez • Compilers In the previous installment we talked about the parsing technology we used, which looks like the canonical academic approach to parsing. In this chapter we will see some dificulties we encountered along the years. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 6 Nov 27, 2016• Roger Ferrer Ibáñez • AArch64 So far we know how to do some computations and access memory. Today we will learn how to alter the control flow of our program. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 5 Nov 13, 2016• Roger Ferrer Ibáñez • AArch64 In this chapter we will see how we can access the memory in AArch64. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 26 Oct 30, 2016• Roger Ferrer Ibáñez • Raspberry Pi In this chapter we will talk about a fascinating step that is required to create a program, even when using assembler. Today we will talk about linking. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 4 Oct 23, 2016• Roger Ferrer Ibáñez • AArch64 In this chapter we will see some instructions that will allow us to compute things. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 3 Oct 23, 2016• Roger Ferrer Ibáñez • AArch64 In the last chapter we saw that instructions may have register operands and immediate operands. We also mentioned that mixing 32-bit and 64-bit register was not allowed. Today we will talk a bit more about register operands. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 2 Oct 8, 2016• Roger Ferrer Ibáñez • AArch64 In the first installment of this series we did a very first simple program. In this chapter we will continue learning a bit more about AArch64. Read on &amp;rarr; How (not) to write a C++ front end – Part 2 Oct 8, 2016• Roger Ferrer Ibáñez • Compilers In the previous installment I gave some context about the existence of Mercurium as a tool. In this chapter we will start digging into the parsing technology used. Read on &amp;rarr; How (not) to write a C++ front end – Part 1 Oct 8, 2016• Roger Ferrer Ibáñez • Compilers As part of the work I did in my previous employer, we had to develop a C++ front end. This is never an easy task so I will use this series to share some experiences while developing it. Read on &amp;rarr; Exploring AArch64 assembler – Chapter 1 Oct 8, 2016• Roger Ferrer Ibáñez • AArch64 AArch64 is a new 64 bit mode that is part of the ARMv8 architecture presented in 2011 by ARM. It has been progressively been deployed in smartphones and servers. So I think it is a good moment to learn a bit more about the assembler of this architecture. Read on &amp;rarr; A tiny GCC front end – Part 11 Sep 5, 2016• Roger Ferrer Ibáñez • Compilers, GCC Our tiny language features a few types: int, float, bool, string and arrays of those types. We can even declare new type names based on other types but it still missing a record type. Today we will address this. Read on &amp;rarr; A tiny GCC front end – Part 10 Sep 4, 2016• Roger Ferrer Ibáñez • Compilers, GCC Today we will add a relatively simple feature that will be very useful for a future extension: type declarations. Read on &amp;rarr; A tiny GCC front end – Part 9 Jan 31, 2016• Roger Ferrer Ibáñez • Compilers, GCC Today we will do something relatively easy: let&#39;s add a way to declare boolean variables and express boolean literals. Read on &amp;rarr; A tiny GCC front end – Part 8 Jan 30, 2016• Roger Ferrer Ibáñez • Compilers, GCC Now that we have the basic language set implemented we can consider adding new features to it. Today we will add arrays. Read on &amp;rarr; A tiny GCC front end – Part 7 Jan 19, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny In this part we will complete the missing statements from part 6 and finish our front end. Read on &amp;rarr; A tiny GCC front end – Part 6 Jan 17, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny In part 5 we described the objects that we will need to semantically analyze a tiny program. In current part we will extend the parser of part 4 to do the semantic analysis and create the GENERIC trees. Read on &amp;rarr; A tiny GCC front end – Part 5 Jan 16, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny In the last installment of this series we saw how to verify that the sequence of tokens of the input is syntactically valid. Today we will see what we need to give it meaning. Read on &amp;rarr; A tiny GCC front end – Part 4 Jan 10, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny Now that we have a stream of tokens we can start performing syntactic analysis. Read on &amp;rarr; A tiny GCC front end – Part 3 Jan 8, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny Now that the minimal infrastructure is already set, we can start with the implementation of our tiny front end. Today we will talk about the lexer. Read on &amp;rarr; A tiny GCC front end – Part 2 Jan 6, 2016• Roger Ferrer Ibáñez • Compilers, GCC • gcc, tiny The previous installment of this series was all about the syntax and the semantics of the tiny language. In this chapter we will start implementing a front end for tiny in GCC. The journey will be long but rewarding. Let&#39;s get started. Read on &amp;rarr; A tiny GCC front end – Part 1 Jan 5, 2016• Roger Ferrer Ibáñez • Compilers, GCC • compilers, frontend, gcc, tiny In this series we will see the process of adding a new front end for a very simple language in GCC. If you, like me, marvel at the magic of compilers then these posts may be for you. Read on &amp;rarr; Toying with GCC JIT – Part 3 Nov 20, 2015• Roger Ferrer Ibáñez • Compilers In the last two parts of this series we&#39;ve seen how to use GCC JIT and how to apply it to a simple regular expression matcher. But an open question remains, has it been worth the effort? This part will try to figure it out. Read on &amp;rarr; Toying with GCC JIT – Part 2 Nov 18, 2015• Roger Ferrer Ibáñez • Compilers One of the quintessential UNIX tools is the grep tool. The global regular expression print is a tool that prints lines of text file that match a given regular expression. In this post we will apply JIT compilation to a very simple regular expression matcher by Rob Pike. Read on &amp;rarr; Toying with GCC JIT – Part 1 Nov 14, 2015• Roger Ferrer Ibáñez • Compilers A just-in-time (JIT) compiler is a compiler that in contrast to the usual compilers is not run ahead-of-time, i.e. before running the actual program, but during the program itself. Read on &amp;rarr; A simple plugin for GCC – Part 3 Aug 17, 2015• Roger Ferrer Ibáñez • Compilers In the last chapter, we extended our plugin so it was possible to visualize the control flow graph of a function. In this chapter we will reach our goal to warn unused results of function calls. Read on &amp;rarr; A simple plugin for GCC – Part 2 Aug 16, 2015• Roger Ferrer Ibáñez • Compilers In the last post we set up everything in order to write a GCC plugin. Before we can go on we need to understand a bit how GCC compiles your files. Read on &amp;rarr; A simple plugin for GCC – Part 1 Aug 16, 2015• Roger Ferrer Ibáñez • Compilers GCC&#39;s C and C++ compilers provide several extensions to address several programming needs not covered in the standards. One of these is the warn_unused_result attribute. This attribute warns us that we are discarding the result of a function. Unfortunately, for C++ it does not always work as expected. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 25 Jul 4, 2015• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, pi, raspberry In chapter 13 we saw VFPv2 and the fact that it allows vectorial operations on floating-point numbers. You may be wondering if such a similar feature exists for integers. The answer is yes although in a more limited way. Read on &amp;rarr; When an array is not an array Feb 26, 2015• Roger Ferrer Ibáñez • Uncategorized • arrays, c language, language, standard c, standardc The C programming language comes with its own set of warts if we closely examine its syntax and semantics. One of the oddities that puzzles most people is the fact that there are no parameters of array types in C. This fact, though, does not prevent one using the array syntax in a parameter. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 24 Jan 9, 2015• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, raspberry Today we will continue with nested functions. Read on &amp;rarr; Read DVDs with bogus permissions in Ubuntu Jan 3, 2015• Roger Ferrer Ibáñez • Linux • debian, fixes, opensource, packages, ubuntu What if your DVD recorder sets bogus permissions to your DVDs? Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 23 Jan 2, 2015• Roger Ferrer Ibáñez • Raspberry Pi Today we will see what happens when we nest a function inside another. It seems a harmless thing to do but it happens to come with its own dose of interesting details. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 22 Dec 20, 2014• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler Several times in previous chapters we have talked about ARM as an architecture that has several features aimed at embedding systems. In embedded systems memory is scarce and expensive, so designs that help reduce the memory footprint are very welcome. Today we will see another of these features: the Thumb instruction set. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 21 Aug 23, 2014• Roger Ferrer Ibáñez • Raspberry Pi We already know that ARM is a 32-bit architecture: general purpose registers are 32-bit wide and addresses in memory are 32-bit numbers. The natural integer size for an architecture is usually called a word and in ARM is obviously 32-bit integers. Sometimes, though, we need to deal with subword data: integers of size smaller than 32 bits. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 20 Aug 20, 2014• Roger Ferrer Ibáñez • Raspberry Pi Today we will see how to make indirect calls. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 19 May 24, 2014• Roger Ferrer Ibáñez • Raspberry Pi So far our small assembler programs have output messages using printf and some of them have read input using scanf. These two functions are implemented in the C library, so they are more or less supported in any environment supporting the C language. But how does a program actually communicate with the world? Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 18 May 11, 2014• Roger Ferrer Ibáñez • Raspberry Pi In this chapter we will delve a bit more into the stack. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 17 Nov 20, 2013• Roger Ferrer Ibáñez • Raspberry Pi In chapter 10 we saw the basics to call a function. In this chapter we will cover more topics related to functions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 16 Aug 23, 2013• Roger Ferrer Ibáñez • Raspberry Pi We saw in chapters 6 and 12 several control structures but we left out a usual one: the switch also known as select/case. In this chapter we will see how we can implement it in ARM assembler. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 15 Aug 11, 2013• Roger Ferrer Ibáñez • Raspberry Pi It may be suprising, but the ARMv6 architecture does not provide an integer division instruction while it does have a floating point instruction in VFPv2. In this chapter we will see usual ways to workaround this limitation with different techniques that can be used in specific scenarios involving divisions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 14 May 12, 2013• Roger Ferrer Ibáñez • Raspberry Pi In chapter 13 we saw the basic elements of VFPv2, the floating point subarchitecture of ARMv6. In this chapter we will implement a floating point matrix multiply using VFPv2. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 13 May 12, 2013• Roger Ferrer Ibáñez • Raspberry Pi So far, all examples have dealt with integer values. But processors would be rather limited if they were only able to work with integer values. Fortunately they can work with floating point numbers. In this chapter we will see how we can use the floating point facilities of our Raspberry Pi. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 12 Mar 28, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, pi, raspberry We saw in chapter 6 some simple schemes to implement usual structured programming constructs like if-then-else and loops. In this chapter we will revisit these constructs and exploit a feature of the ARM instruction set that we have not learnt yet. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 11 Mar 16, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, branches, function, function call, functions, pi, predication, raspberry Several times, in earlier chapters, I stated that the ARM architecture was designed with the embedded world in mind. Although the cost of the memory is everyday lower, it still may account as an important part of the budget of an embedded system. The ARM instruction set has several features meant to reduce the impact of code size. One of the features which helps in such approach is predication. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 10 Feb 7, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, function, function call, functions, pi, raspberry, stack In chapter 9 we were introduced to functions and we saw that they have to follow a number of conventions in order to play nice with other functions. We also briefly mentioned the stack, as an area of memory owned solely by the function. In this chapter we will go in depth with the stack and why it is important for functions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 9 Feb 2, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, function, function call, functions, pi, raspberry In previous chapters we learnt the foundations of ARM assembler: registers, some arithmetic operations, loads and stores and branches. Now it is time to put everything together and add another level of abstraction to our assembler skills: functions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 8 Jan 27, 2013• Roger Ferrer Ibáñez • Raspberry Pi • addresses, arm, assembler, indexing modes, pi, postindex, preindex, raspberry In the previous chapter we saw that the second operand of most arithmetic instructions can use a shift operator which allows us to shift and rotate bits. In this chapter we will continue learning the available indexing modes of ARM instructions. This time we will focus on load and store instructions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 7 Jan 26, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, indexing modes, pi, raspberry ARM architecture has been for long targeted at embedded systems. Embedded systems usually end being used in massively manufactured products (dishwashers, mobile phones, TV sets, etc). In this context margins are very tight so a designer will always try to spare as much components as possible (a cent saved in hundreds of thousands or even millions of appliances may pay off). One relatively expensive component is memory although every day memory is less and less expensive. Anyway, in constrained memory environments being able to save memory is good and ARM instruction set was designed with this goal in mind. It will take us several chapters to learn all of these techniques, today we will start with one feature usually named shifted operand. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 6 Jan 20, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, control structures, pi, raspberry Control structures In the previous chapter we learnt branch instructions. They are really powerful tools because they allow us to express control structures. Structured programming is an important milestone in better computing engineering (a foundational one, but nonetheless an important one). So being able to map usual structured programming constructs in assembler, in our processor, is a Good Thing™. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 5 Jan 19, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, branches, pi, raspberry Branching Until now our small assembler programs execute one instruction after the other. If our ARM processor were only able to run this way it would be of limited use. It could not react to existing conditions which may require different sequences of instructions. This is the purpose of the branch instructions. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 4 Jan 12, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, debugger, gdb, pi, raspberry As we advance learning the foundations of ARM assembler, our examples will become longer. Since it is easy to make mistakes, I think it is worth learning how to use GNU Debugger gdb to debug assembler. If you develop C/C++ in Linux and never used gdb, shame on you. If you know gdb this small chapter will explain you how to debug assembler directly. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 3 Jan 11, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, load, pi, raspberry, store We saw in chapter 1 and chapter 2 that we can move values to registers (using mov instruction) and add two registers (using add instruction). If our processor were only able to work on registers it would be rather limited. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 2 Jan 10, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, pi, raspberry Registers At its core, a processor in a computer is nothing but a powerful calculator. Calculations can only be carried using values stored in very tiny memories called registers. The ARM processor in a Raspberry Pi has 16 integer registers and 32 floating point registers. A processor uses these registers to perform integer computations and floating point computations, respectively. We will put floating registers aside for now and eventually we will get back to them in a future installment. Let’s focus on the integer registers. Read on &amp;rarr; ARM assembler in Raspberry Pi – Chapter 1 Jan 9, 2013• Roger Ferrer Ibáñez • Raspberry Pi • arm, assembler, pi, raspberry In my opinion, it is much more beneficial learning a high level language than a specific architecture assembler. But I fancied learning some ARM assembler just for fun since I know some 386 assembler. The idea is not to become a master but understand some of the details of what happens underneath. Read on &amp;rarr; Common linking issues in C++ Aug 8, 2012• Roger Ferrer Ibáñez • Uncategorized Introduction C++ is a language derived from C, so in essence all problems at link time boil down at declaring stuff but not defining it. Declaring something in C++ means bringing the entity into existence in the program, so it can be used after the declaration point. Defining something means giving a complete description of the entity itself. You can declare a class or a function, and it means this class and this function do exist. But to completely describe a class and a function you have to define them. A class definition provides a list of base classes of that class, a list of members (data members and member functions) of that class, etc. A function definition provides the executable code of that function. All definitions are declarations but not all declarations are definitions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Defines variable &#39;x&#39; int x; // Declares variable &#39;y&#39; extern int y; // Declares class &#39;A&#39; struct A; // Declares function &#39;f(int)&#39; void f(int); // Defines class &#39;A&#39; struct A { // Declares member function &#39;A::g(float)&#39; void g(float); // Defines member function &#39;A::h(char)&#39; void h(char) { // Code } // Defines data member &#39;A::x&#39; int x; // Declares static data member &#39;A::y&#39; static int y; }; // Defines function&#39;f(int)&#39; void f(int) { // Code } // Defines member function &#39;A::g(float)&#39; void A::g(float) { // Code } // Defines static data member &#39;A::y&#39; int A::y; C++, in contrast to C, strongly sticks to the One Definition Rule which states that entities can be defined at most once in an entire program. Of course this may not be completely true depending your own the definition of &quot;entity&quot;: template functions when instantiated by the compiler can be defined more than once in the program, and some magic happens so this does not become a problem. Anyway, C++ brings its own set of linking issues which may fool even the most experienced C++ developer. Static data members are only declared inside the class specifier Some might argue that this is one of the most common source of linking issues when using C++. Truth be told, static data members are just global variables in disguise so most people will avoid them. However, there are cases where a static data member may come in handy, for instance when implementing the singleton pattern. The problem lies that, although usual (nonstatic) data members are defined when they are declared inside a class (like in line 23 of the example above), static data members are only declared. Thus in line 26 of the example above A::y is only being declared. Its actual definition is given in line 42. The actual definition of a static data member will go in the implementation file (usually a .cpp or .cc file). So the usual case goes like this: you realize you need a static data member. You add it to the class. Your code compiles fine but does not link. In fact &#39;A::y&#39;, the static data member you just added is undefined? How can this be? Now you know the reason. What is the reason this issue is hit so many times? Well, there are three reasons. A historical one, where early versions of C++ compilers allowed this. A quirk in the C++ language itself where const integral and enumerator static data members can be declared and initialized in the class itself (thus defining them as well). And finally, a linguistic issue, since in Java and C# static fields are declared like any other fields plus a static specifier. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // -- Header file class MySingleton { public: static MySingleton&amp;amp; getInstance() { if (singleton_ == 0) singleton_ = new MySingleton; return *singleton_; } private: // Usual private constructor MySingleton() { } // Declaration static MySingleton *singleton_; }; // -- Implementation file // Definition MySingleton* MySingleton::singleton_ = 0; Not all headers are created equal The usual myth is that C++ is a superset of C. Well, it looks like as a superset of C but they are actually two different languages. That said, they share so many thinks that interfacing C++ and C is pretty straightforward, in particular when the former must call the latter (the opposite may be a bit more challenging). Thus, it is not unsual to see that a C++ program #includes C header files. Chances are that the headers of your operating system will be in C. Being able to #include a C header and using the entities declared in it is one of the strengths of C++. And this is the source of our second problem. Remember that in C++ functions may be overloaded. This means that we can use the same name when declaring two functions in the same scope as long as they have different enough parameter types. 1 2 3 4 5 6 7 // Declaration of &#39;f(int)&#39; void f(int); // Declaration of &#39;f(float)&#39; void f(float); // Redeclaration of &#39;f(int)&#39; since, in a parameter, &#39;const int&#39; cannot // be distinguished from &#39;int&#39; void f(const int); It may be non obvious, but we cannot give these two functions declared above the same f name. So the compiler crafts an artificial name for f(int) and f(float) (this is called a decorated name or a mangled name). For instance they could be f_1_int and f_1_float (here 1 would mean the number of parameters). The C++ compiler will internally use these names when generating code and the lower levels will just see two diferent names. But overloading cannot be applied to C. Thus we run into a problem here. If we #include C headers, the names of these functions cannot be overloaded thus a C compiler will generated code using the (undecorated) name of the function. If our C++ compiler always uses a decorated name, there will be an unresolved symbol. The C++ compiler cannot tell if this is C or C++. Can it? Good news, it can. You can define the linkage of declarations in the code. By default linkage is C++ so overload works as described above. When you want to #include a C header, you will have to tell the C++ compiler that the linkage of the declarations is C, not C++. Most of the time you will find these lines in the beginning of a C header intended to be used from C++. 1 2 3 4 5 6 7 8 9 10 11 12 13 // Remember this is a C header so protect ourselves when this is compiled using C #ifdef __cplusplus // This &#39;extern &quot;C&quot;&#39; syntax is only valid in C++, not in C. extern &quot;C&quot; { // From now everything has C linkage. #endif /* Library declarations in C */ #ifdef __cplusplus // Close the brace opened above } #endif Virtual member functions and virtual tables Finally one of the, in my opinion, most confusing link errors when using a C++ compilers: virtual table unresolved references. Virtual member functions are, in C++ parlance, polymorphic methods of other programming languages (like Java). Virtual member functions can be overridden by derived classes (descendant classes) thus when called, they must be dispatched dinamically. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct A { virtual void vmf(float*); virtual void vmf2(float*); }; struct B : A { virtual void vmf(float*); virtual void vmf3(float*); }; virtual B::vmf(float*) { // Code } void g(A* pa, float *pfl) { // Dynamic dispatch // we don&#39;t really know if A::vmf or B::vmf will be called pa-&amp;gt;vmf(pfl); // Static call to A::vmf since we qualified the function being called pa-&amp;gt;A::vmf(pfl); B b; // Static call to B::vmf, no doubts here since the dynamic type (in memory) // of &#39;b&#39; and its declared type must be the same b.vmf(pfl); A&amp;amp; ra(*pa); // Dynamic dispatch again ra.vmf(pfl); } Dynamic dispatch is implemented using a virtual method table (or vtable). Every class with virtual methods (called a dynamic class) has a vtable. This vtable is a sequence of addresses to member functions. Every virtual member function is assigned an index in this table and the addresses points to the function implementing the virtual member function for that class. For instance class A above has two member functions vmf and vmf2. The vtable of A, then will have two entries, 0 and 1, and will point to the functions A::vmf and A::vmf2 respectively. The vtable of B will have three entries, 0, 1, 2, that will point to functions B::vmf, A::vmf2 and B::vmf3 respectively. Every object of a dynamic class has a hidden data member (called the virtual pointer) that points to the vtable of its class. When C++ specifies that a call goes through dynamic dispatch (in C++ parlance, a call to the ultimate overrider), we do not call directly any function but instead, through this hidden data member, we reach the vtable and using the index of the virtual member function being called, we retrieve the entry containing the addresses to the real function. Then this addresses is used in an indirect call. Since both the virtual table and the virtual pointer are hidden from the eyes of the developer, sometimes errors in our code may cause link errors. The compiler does not emit a vtable This may not apply to all C++ compilers, but usually a C++ compiler only emits a vtable when it finds a definition of a virtual member function. Note that virtual member function definitions for a given class may be scattered in several files. Magic happens again so more than one definition of the vtable of a given class in several files does not become a problem at link time. But, what if you forget to define all virtual functions? This may look contrived but in my experience this may happen by accident. The problem lies on the error at link time, which is really confusing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct A { int x_; A(int x) : x_(x) { } // We forget to define A::foo virtual void foo(); }; void quux(A* a) { // Dynamic dispatch a-&amp;gt;foo(); } int main(int argc, char * argv[]) { A a(3); quux(&amp;amp;a); } If you compile and link this with g++ (I use -g since it improves link error messages by using the debugging information). $ g++ -o prova test.cc -g /tmp/ccl71r2A.o: In function `A&#39;: test.cc:4: undefined reference to `vtable for A&#39; collect2: ld returned 1 exit status But the line 4 is the constructor. You see now how confusing this message is, don&#39;t you? What is going on? Well, everything makes sense if we remember that hidden data member I mentioned above, the virtual pointer. As a data member of a class it must be initialized in the constructor. It is initialized with the address of the virtual table of A. But the virtual table of A was not emitted since we forgot to define all virtual member functions. Thus, unresolved reference for the virtual table. Missing virtual member functions in base classes Remember that the vtable contains entries for all the virtual member functions of the base tables. The vtable is statically initialized (this is, the compiler &quot;hardcodes&quot; in the generated code, in the data section) the addresses of each entry. What if we forget to define a virtual member function of a base class? Consider this example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct A { int x_; A(int x) : x_(x) { } virtual void foo(); // We forget to define A::foo2 virtual void foo2(); }; void A::foo() { // Definition of A::foo } struct B : A { B(int x) : A(x) { } virtual void foo() { // Definition of B::foo } }; void quux(A* a) { a-&amp;gt;foo(); } int main(int argc, char * argv[]) { B b(3); quux(&amp;amp;b); } If we compile and link with g++ we get /tmp/cc4t9NG3.o:(.rodata._ZTV1B[vtable for B]+0xc): undefined reference to `A::foo2()&#39; /tmp/cc4t9NG3.o:(.rodata._ZTV1A[vtable for A]+0xc): undefined reference to `A::foo2()&#39; collect2: ld returned 1 exit status This happens because vtables of A and B refer to A::foo2, but we forgot to define it. Fortunately, now the error message is easier to grasp: some function is missing. Obviously, many more link errors caused by C++ exist, but I think the ones shown here are quite common and the error messages related to them are quite confusing. Crazy stuff in C++ (1) Jul 29, 2012• Roger Ferrer Ibáñez • Uncategorized • classes, cplusplus, functions, specializations, templates Introduction C++ is a controversial language: you love it or you hate it. As always, knowing better about something allows one to make better arguments for or against that thing. This is what this series is about. Here I’ll explain some of the less known (except for C++ expert programmers, of course) features of C++. Let’s start with templates, which account for such a huge part of the language. Templates Everyone knows that C++ has templates. Templates is an implementation of the «I have an algorithm that can be used with many different types» idea. This idea is called generic programming and is a pretty powerful one. This is why it is present in almost all modern languages. Back to C++. C++ defines two kinds of templates: classes templates and function templates. Class templates define an infinite set of classes while function templates define an infinite set of functions. The elements of these sets of classes or functions are called specializations. Every template has a template-name which will be used to name a specific specialization. Template declarations Consider these two declarations 1 2 template &amp;lt;typename T&amp;gt; struct my_list { ... } 1 2 template &amp;lt;typename T&amp;gt; void max(T a, T b) { return a &amp;gt; b ? a : b; } These are template declarations. The first one declares a class template and its template-name is my_list, the second one defines a function template and its template-name is max. A template declaration is just a declaration preceded with something without an official name that starts with template &amp;lt;…&amp;gt;, I will call it the template header (but note that this name is not blessed by the C++ standard at all, it just makes sense to me call it like this). The template header defines what are the parameters of the template class. These are called the template parameters. A type-template parameter, like that T shown above, is a “type variable”. This is the most usual template parameter as it allows to parameterize the declaration over one or more type variables. C++, though, has two more kinds of template parameters: nontype-template parameters and (the funny named) template-template parameter. A nontype-template parameter allows us to parameterize the declaration over a (compile-time) constant integer value. Here “integer value” is a very broad term: of course it includes all integers, but also enum values (enumerators) and addresses of (statically allocated) variables and functions. A template-template parameter allows us to parameterize a declaration over another class template with appropiate template parameters. 1 2 template &amp;lt;typename T, int N&amp;gt; // N is a nontype-template parameter struct my_fixed_array { }; 1 2 template &amp;lt;template &amp;lt;typename T&amp;gt; MyContainer&amp;gt; // MyContainer is a template-template parameter struct adaptor { }; Specializations I said above that a class template or function template defines an infinite set of classes or function and that each element of that set was called a specialization. There is a specialization for every possible value that a template parameter can have. Such values are not bounded thus there is an infinite number of specializations (well, we could argue that constant integer values are finite in the language, but types are clearly not finite). We give value to template parameters of a template by means of template arguments. These template arguments always appear in what is called a template-id. A template-id is just the template-name followed by a list of template-arguments enclosed in &amp;lt; and &amp;gt;. 1 2 my_list&amp;lt;int&amp;gt; l;// Here T has value int, we will write it as T ← int max&amp;lt;float&amp;gt;(3.4f, 5.6f); // T ← float Primary template and partial specializations When we first declare a class template or a function template, such declaration defines the primary template. 1 2 template &amp;lt;typename T&amp;gt; struct my_list { ... }; 1 2 template &amp;lt;typename T&amp;gt; void swap(T&amp;amp; a, T&amp;amp; b); Class templates (but not function templates!) can have an extra set of template declarations called partial specializations. A partial specialization looks like a normal class template declaration but the template-name is now a template-id where the template-arguments partially specialize the given template parameters. 1 2 3 4 5 6 7 8 9 10 11 12 // 1) Partial specialization for &quot;pointer to (any) P&quot; type template &amp;lt;typename P&amp;gt; struct my_list&amp;lt;P*&amp;gt; { }; // 2) Partial specialization for &quot;array of (any) Size of (any) Element&quot; template &amp;lt;typename Element, int Size&amp;gt; struct my_list&amp;lt;Element[Size]&amp;gt; { }; // 3) Partial specialization for &quot;pointer to function with two parameters // Arg1 and Arg2 returning Ret&quot; template &amp;lt;typename Ret, typename Arg1, typename Arg2&amp;gt; struct my_list&amp;lt;Ret (*)(Arg1, Arg2)&amp;gt;; A C++ compiler will always pick the partial specialization (if any) that is “closer” to the one requested in the template arguments. If no partial specialization matches, the primary template is chosen instead. The exact algorithm is not important here. 1 2 3 4 5 6 7 8 9 10 my_list&amp;lt;int&amp;gt; l0; // will pick the primary template T ← int my_list&amp;lt;int*&amp;gt; l1; // will pick partial specialization 1) // where P ← int (note that respect to the primary template this is T ← int*) my_list&amp;lt;int[10]&amp;gt; l2; // will pick partial specialization 2) // where Element ← int and Size ← 10 my_list&amp;lt;int (*)(float, double)&amp;gt; l3; // will pick partial specialization 3) // where Ret ← int, Arg1 ← float and Arg2 ← double I think this is enough for today regarding C++ templates. More craziness to come. Stay tuned.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Posts by Roger Ferrer Ibáñez">
  <meta name="twitter:description" content="Fun with vectors in the Raspberry Pi 1 - Part 2 Jun 25, 2021• Roger Ferrer Ibáñez • vectors, raspberry pi 1, llvm, compilers, arm Ok so in the previous installment we discussed a bit how to generat...">
  
  

  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
<link href="https://fonts.googleapis.com/css?family=Fira+Mono:400,700" rel="stylesheet">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

      <span class="site-title"><a href="/">Think In Geek</a> | </span>
      <span class="site-slogan">In geek we trust</span>

    <nav class="site-nav"><a class="page-link" href="/arm-assembler-raspberry-pi/">Arm Assembler Raspberry Pi</a><a class="page-link" href="/gcc-tiny/">GCC tiny</a><a class="page-link" href="/author/brafales/">Posts by Bernat Ràfales</a><a class="page-link" href="/archives/">Archives</a></nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Posts by Roger Ferrer Ibáñez</h1>
  </header>

  <div class="post-content">
    <ul class="post-list"><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2021/06/25/raspberry-vectors-part-2/">Fun with vectors in the Raspberry Pi 1 - Part 2</a></h1>

        <p class="post-meta">
          Jun 25, 2021• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/vectors/">vectors</a>, <a href="/categories/raspberry-pi-1/">raspberry pi 1</a>, <a href="/categories/llvm/">llvm</a>, <a href="/categories/compilers/">compilers</a>, <a href="/categories/arm/">arm</a></p>
      </header>

      <div class="post-content">
        <p>Ok so in the <a href="/2021/06/25/raspberry-vectors-part-1/">previous installment</a>
we discussed a bit how to generate code using the vector feature of the CPU of
the Raspberry Pi 1.</p>

<p>Let’s start hacking LLVM.</p>


      </div><p class="post-continue">
          <a href="/2021/06/25/raspberry-vectors-part-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2021/06/25/raspberry-vectors-part-1/">Fun with vectors in the Raspberry Pi 1 - Part 1</a></h1>

        <p class="post-meta">
          Jun 25, 2021• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/vectors/">vectors</a>, <a href="/categories/raspberry-pi-1/">raspberry pi 1</a>, <a href="/categories/llvm/">llvm</a>, <a href="/categories/compilers/">compilers</a>, <a href="/categories/arm/">arm</a></p>
      </header>

      <div class="post-content">
        <p><a href="/2013/05/12/arm-assembler-raspberry-pi-chapter-13/">
Long ago, we saw that the Raspberry Pi 1 has vector computation
capabilities.</a>. However to the best of my knowledge no compiler attempted to
exploit the vector capability in general.</p>

<p>I think we are going to have some fun in trying to fix this.</p>


      </div><p class="post-continue">
          <a href="/2021/06/25/raspberry-vectors-part-1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2021/03/01/raii-locks-clang-tidy/">RAII, locks and clang-tidy</a></h1>

        <p class="post-meta">
          Mar 1, 2021• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/c/">c++</a>, <a href="/categories/raii/">raii</a>, <a href="/categories/clang-tidy/">clang-tidy</a>, <a href="/categories/locks/">locks</a></p>
      </header>

      <div class="post-content">
        <p>A colleague of mine spent some time chasing a bug in a C++ library related
to concurrency.</p>

<p>At the end it all boiled down to a silly declaration that wasn’t one.</p>


      </div><p class="post-continue">
          <a href="/2021/03/01/raii-locks-clang-tidy/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2020/11/22/process-wide-information-and-keys/">Process-wide information and Linux key management</a></h1>

        <p class="post-meta">
          Nov 22, 2020• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/linux/">linux</a>, <a href="/categories/libraries/">libraries</a>, <a href="/categories/programming/">programming</a></p>
      </header>

      <div class="post-content">
        <p>I believe this is not a very common scenario, but sometimes one has to develop
libraries whose scope is the whole process. In such a situation, we may need to
identify if a process has already loaded another copy of the library.</p>


      </div><p class="post-continue">
          <a href="/2020/11/22/process-wide-information-and-keys/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2020/06/20/forgotten-memories-2/">Forgotten memories (2)</a></h1>

        <p class="post-meta">
          Jun 20, 2020• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">compilers</a>, <a href="/categories/llvm/">llvm</a>, <a href="/categories/risc-v/">risc-v</a></p>
      </header>

      <div class="post-content">
        <p>So in the <a href="/2020/06/20/forgotten-memories-1/">first part of this experiment</a>
we saw a simple strategy to spill general-purpose registers into floating-point
registers implemented in the RISC-V backend of LLVM.</p>

<p>In this chapter, let’s see the results and some other interesting facts learnt
during the process.</p>


      </div><p class="post-continue">
          <a href="/2020/06/20/forgotten-memories-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2020/06/20/forgotten-memories-1/">Forgotten memories (1)</a></h1>

        <p class="post-meta">
          Jun 20, 2020• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">compilers</a>, <a href="/categories/llvm/">llvm</a>, <a href="/categories/risc-v/">risc-v</a></p>
      </header>

      <div class="post-content">
        <p>Most compiler infrastructures that target register machines do it by using the
concept of <em>virtual registers</em>. In their intermediate representations instructions
use virtual registers to represent their operands.</p>

<p>Because hardware is finite, these virtual registers must be mapped to physical
registers at some point. The compiler does this in a process called <a href="https://en.wikipedia.org/wiki/Register_allocation"><em>register
allocation</em></a>.</p>

<p>Being physical registers finite, it may happen that not all the virtual
registers used by the program can be held in physical registers at the same
time. When this happens, the compiler must emit <em>spill code</em>. Spill code stores
a value in a memory (<em>spill</em>) and loads it later, often close to the point of
use (<em>reload</em>).</p>

<p>The memory used for spill code is commonly the <em>function stack</em>. However
nothing prevents us from using other kinds of “memories” as long as we can
guarantee that nobody is going to use them. This is exactly the kind of
experiment we will do today: we’re going to spill general-purpose registers
into floating-point registers.</p>


      </div><p class="post-continue">
          <a href="/2020/06/20/forgotten-memories-1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2020/06/06/local-domain-and-dhcp-with-dnsmasq/">Create your own local domain and DHCP with dnsmasq</a></h1>

        <p class="post-meta">
          Jun 6, 2020• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/dns/">dns</a>, <a href="/categories/dhcp/">dhcp</a></p>
      </header>

      <div class="post-content">
        <p><a href="/2007/06/19/create-your-own-local-domain-with-dhcp-and-bind/">Back in 2007</a>, Bernat
explained how to set up our own domain name using ISC BIND and ISC DHCP. You
can’t go wrong with those servers but maybe you prefer something more
straightforward. I present here a simpler alternative built on top of
<a href="http://www.thekelleys.org.uk/dnsmasq/doc.html"><code class="language-plaintext highlighter-rouge">dnsmasq</code></a> which is an
integrated DNS and DHCP.</p>


      </div><p class="post-continue">
          <a href="/2020/06/06/local-domain-and-dhcp-with-dnsmasq/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2020/06/06/using-ssh-certificates/">Using SSH Certificates</a></h1>

        <p class="post-meta">
          Jun 6, 2020• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/ssh/">ssh</a></p>
      </header>

      <div class="post-content">
        <p>Password-based authentication has a number of drawbacks, so many services (such
as github) use SSH keys to authenticate. However distributing the keys over
several nodes (be virtual machines or single-board computers such as
Raspberry Pi) doesn’t scale over the number of nodes and users.</p>

<p>Luckily, OpenSSH implementation of SSH supports a certificate-based mechanism.
This mechanism may help reducing the complexity of users trusting SSH hosts and
hosts trusting SSH users.</p>


      </div><p class="post-continue">
          <a href="/2020/06/06/using-ssh-certificates/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2019/03/10/fortran-and-modules/">Fortran and modules</a></h1>

        <p class="post-meta">
          Mar 10, 2019• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <!-- wp:paragraph -->
<p>Recently the committee that is preparing the next standard of C++, known as C++20, approved the inclusion of modules. Modules are good™ but they pose some interesting challenges to implementors and users. In this post I will ruminate a bit about what challenges have impacted Fortran.</p>
<!-- /wp:paragraph -->

<!-- wp:more -->

      </div><p class="post-continue">
          <a href="/2019/03/10/fortran-and-modules/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2018/12/22/walk-through-flang-part-8/">Walk-through flang – Part 8</a></h1>

        <p class="post-meta">
          Dec 22, 2018• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>In the last installment of this series we started to look at the AST and the symbol table by examining the compiler dumps of these two data structures. In this chapter we are going to explore a bit more the AST for the control flow statements.</p>


      </div><p class="post-continue">
          <a href="/2018/12/22/walk-through-flang-part-8/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2018/08/25/walk-through-flang-part-7/">Walk-through flang – Part 7</a></h1>

        <p class="post-meta">
          Aug 25, 2018• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>
In previous chapters we saw how the input source was lexed, parsed and semantically analysed and we looked at how the symbols and data types are represented. But we haven't looked at what happens once the semantic analysis finishes. In this installment we're going to talk about the AST.
</p>

      </div><p class="post-continue">
          <a href="/2018/08/25/walk-through-flang-part-7/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2018/03/18/walk-through-flang-part-6/">Walk-through flang – Part 6</a></h1>

        <p class="post-meta">
          Mar 18, 2018• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>At this point we should have a reasonable picture of how flang parses and generates semantic information. So now it is time to explore with more detail what is actually synthesized and how it can be used later in the compiler. In this chapter we are going to see the symbol table.</p>


      </div><p class="post-continue">
          <a href="/2018/03/18/walk-through-flang-part-6/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/11/19/simple-memory-pool/">A very simple memory pool in C++11</a></h1>

        <p class="post-meta">
          Nov 19, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/uncategorized/">Uncategorized</a></p>
      </header>

      <div class="post-content">
        <p>I’ve been implementing an algorithm that works on a graph. That algorithm needs to create and destroy lots of nodes and edges to keep track of the algorithm state correctly. The algorithm also needs to be fast in order to be competitive against a similar algorithm that uses sets of stacks instead of graphs. Profiles show that memory allocations are impacting negatively the performance, so maybe a memory pool can help.</p>


      </div><p class="post-continue">
          <a href="/2017/11/19/simple-memory-pool/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/11/05/exploring-aarch64-assembler-chapter-9/">Exploring AArch64 assembler – Chapter 9</a></h1>

        <p class="post-meta">
          Nov 5, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>In chapter 6 we saw conditional branches and we ended commenting that they can be used to implement higher control constructs. In this chapter we will see a few of them.</p>

      </div><p class="post-continue">
          <a href="/2017/11/05/exploring-aarch64-assembler-chapter-9/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/10/07/walk-through-flang-part-5/">Walk-through flang – Part 5</a></h1>

        <p class="post-meta">
          Oct 7, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>In the previous installment of this series we saw how flang parses the statements using an LR(1) algorithm. As the parser recognized the parts of the statements it invokes semantic actions. Today we’re going to talk more about them.</p>


      </div><p class="post-continue">
          <a href="/2017/10/07/walk-through-flang-part-5/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/09/03/walk-through-flang-part-4/">Walk-through flang – Part 4</a></h1>

        <p class="post-meta">
          Sep 3, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>In the last installment we saw how flang splits the input in tokens. Once we have the tokens identified we need to parse them.</p>

      </div><p class="post-continue">
          <a href="/2017/09/03/walk-through-flang-part-4/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/07/29/walk-through-flang-part-3/">Walk-through flang – Part 3</a></h1>

        <p class="post-meta">
          Jul 29, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>In the last chapter we saw how the driver handles the compilation and how it invokes <code>flang1</code> and <code>flang2</code>. In this chapter we are going to start with <code>flang1</code>.</p>

      </div><p class="post-continue">
          <a href="/2017/07/29/walk-through-flang-part-3/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/06/17/walk-through-flang-part-2/">Walk-through flang – Part 2</a></h1>

        <p class="post-meta">
          Jun 17, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>
In the previous installment of this series we saw basically how to install flang and we ran a simple smoke test. In this post we will see a high level overview of what happens when we compile a Fortran program using flang. We will also compare it with what usually happens with clang.
</p>

      </div><p class="post-continue">
          <a href="/2017/06/17/walk-through-flang-part-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/06/17/walk-through-flang-part-1/">Walk-through flang – Part 1</a></h1>

        <p class="post-meta">
          Jun 17, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p><a href="https://github.com/flang-compiler/flang">Flang</a> is an open source project to create a Fortran compiler for LLVM. It is based on <a href="http://www.pgroup.com/">NVIDIA/PGI Fortran</a> and it has been released under Apache License 2.0. In this series we will do a walk-through the code of this compiler and how it has been integrated in the existing LLVM infrastructure.</p>


      </div><p class="post-continue">
          <a href="/2017/06/17/walk-through-flang-part-1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/06/15/10-years-geek/">10 years of Think In Geek</a></h1>

        <p class="post-meta">
          Jun 15, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/uncategorized/">Uncategorized</a></p>
      </header>

      <div class="post-content">
        <p>
10 years ago Bernat (brafales) <a href="/2007/06/15/think-in-geek/">started this blog</a>. This is still his blog though he is a bit busy these days and he cannot publish as much as he wants.
</p>
<p>
All in all, without his initiative this blog would not exist. As would not exist many of the posts I published here since 2012, when Bernat insisted that I should collaborate. I guess his persistence has somehow paid off :)
</p>
<p>
Consider this post a very small celebration of those 10 years. Hopefully we will be able to celebrate many more years.
</p>

      </div></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/05/31/compilers-memory-error-detectors/">Compilers as a memory error detectors</a></h1>

        <p class="post-meta">
          May 31, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>This is a small anecdote of something that happened to me the other day.</p>

      </div><p class="post-continue">
          <a href="/2017/05/31/compilers-memory-error-detectors/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/05/29/exploring-aarch64-assembler-chapter-8/">Exploring AArch64 assembler – Chapter 8</a></h1>

        <p class="post-meta">
          May 29, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>In the last chapter we saw how to call a function. We mentioned a special memory called the stack but we did not delve into it. Let’s see in this chapter how we can use the stack and why it is important in function calls.</p>


      </div><p class="post-continue">
          <a href="/2017/05/29/exploring-aarch64-assembler-chapter-8/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/04/17/arm-assembler-raspberry-pi-chapter-27/">ARM assembler in Raspberry Pi – Chapter 27</a></h1>

        <p class="post-meta">
          Apr 17, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
We saw in the previous chapter what is the process required to build a program from different compilation units. This process happened before we obtained the final program. The question is, can this process happen when the program runs? This is, is it possible to dynamically link a program?
</p>

      </div><p class="post-continue">
          <a href="/2017/04/17/arm-assembler-raspberry-pi-chapter-27/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/04/02/optimization/">Whose is this optimization?</a></h1>

        <p class="post-meta">
          Apr 2, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
Today we will toy around a very simple optimization in clang and discuss a bit about separation of concerns when optimizing code.
</p>


      </div><p class="post-continue">
          <a href="/2017/04/02/optimization/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/03/19/exploring-aarch64-assembler-chapter-7/">Exploring AArch64 assembler – Chapter 7</a></h1>

        <p class="post-meta">
          Mar 19, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>
In the previous installment of this series we saw how to alter the sequencing of our programs. Today we will see how we can reuse instructions by means of branches. Let's talk about functions.
</p>

      </div><p class="post-continue">
          <a href="/2017/03/19/exploring-aarch64-assembler-chapter-7/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/02/25/compilation-array-expressions-fortran/">Compilation of array expressions in Fortran</a></h1>

        <p class="post-meta">
          Feb 25, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>As I stated in my previous post, Fortran 90 improved the array capabilities of Fortran. Today we will discuss what are the challenges when compiling array expressions.</p>


      </div><p class="post-continue">
          <a href="/2017/02/25/compilation-array-expressions-fortran/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2017/01/14/gfortran-array-descriptor/">Introduction to the gfortran array descriptor</a></h1>

        <p class="post-meta">
          Jan 14, 2017• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/fortran/">Fortran</a></p>
      </header>

      <div class="post-content">
        <p>With the approval of Fortran 90, its array capabilities were largely improved. While still far from languages like APL, the extra functionality required a rethinking of the concept array in Fortran. This led to the need for array descriptors in the language.</p>


      </div><p class="post-continue">
          <a href="/2017/01/14/gfortran-array-descriptor/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/12/03/not-write-c-front-part-3/">How (not) to write a C++ front end – Part 3</a></h1>

        <p class="post-meta">
          Dec 3, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
In the previous installment we talked about the parsing technology we used, which looks like the canonical academic approach to parsing. In this chapter we will see some dificulties we encountered along the years.
</p>


      </div><p class="post-continue">
          <a href="/2016/12/03/not-write-c-front-part-3/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/11/27/exploring-aarch64-assembler-chapter-6/">Exploring AArch64 assembler – Chapter 6</a></h1>

        <p class="post-meta">
          Nov 27, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>
So far we know how to do some computations and access memory. Today we will learn how to alter the control flow of our program.
</p>

      </div><p class="post-continue">
          <a href="/2016/11/27/exploring-aarch64-assembler-chapter-6/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/11/13/exploring-aarch64-assembler-chapter-5/">Exploring AArch64 assembler – Chapter 5</a></h1>

        <p class="post-meta">
          Nov 13, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>
In this chapter we will see how we can access the memory in AArch64.
</p>


      </div><p class="post-continue">
          <a href="/2016/11/13/exploring-aarch64-assembler-chapter-5/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/10/30/arm-assembler-raspberry-pi-chapter-26/">ARM assembler in Raspberry Pi – Chapter 26</a></h1>

        <p class="post-meta">
          Oct 30, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>In this chapter we will talk about a fascinating step that is required to create a program, even when using assembler. Today we will talk about linking.</p>


      </div><p class="post-continue">
          <a href="/2016/10/30/arm-assembler-raspberry-pi-chapter-26/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/10/23/exploring-aarch64-assembler-chapter-4/">Exploring AArch64 assembler – Chapter 4</a></h1>

        <p class="post-meta">
          Oct 23, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>
In this chapter we will see some instructions that will allow us to compute things.
</p>


      </div><p class="post-continue">
          <a href="/2016/10/23/exploring-aarch64-assembler-chapter-4/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/10/23/exploring-aarch64-assembler-chapter-3/">Exploring AArch64 assembler – Chapter 3</a></h1>

        <p class="post-meta">
          Oct 23, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>
In the last chapter we saw that instructions may have register operands and immediate operands. We also mentioned that mixing 32-bit and 64-bit register was not allowed. Today we will talk a bit more about register operands.
</p>


      </div><p class="post-continue">
          <a href="/2016/10/23/exploring-aarch64-assembler-chapter-3/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/10/08/exploring-aarch64-assembler-chapter-2/">Exploring AArch64 assembler – Chapter 2</a></h1>

        <p class="post-meta">
          Oct 8, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>
In the first installment of this series we did a very first simple program. In this chapter we will continue learning a bit more about AArch64.
</p>

      </div><p class="post-continue">
          <a href="/2016/10/08/exploring-aarch64-assembler-chapter-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/10/08/not-write-c-parser-part-2/">How (not) to write a C++ front end – Part 2</a></h1>

        <p class="post-meta">
          Oct 8, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
In the previous installment I gave some context about the existence of Mercurium as a tool. In this chapter we will start digging into the parsing technology used.
</p>

      </div><p class="post-continue">
          <a href="/2016/10/08/not-write-c-parser-part-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/10/08/not-write-c-parser-part-1/">How (not) to write a C++ front end – Part 1</a></h1>

        <p class="post-meta">
          Oct 8, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
As part of the work I did in my previous employer, we had to develop a C++ front end. This is never an easy task so I will use this series to share some experiences while developing it.
</p>

      </div><p class="post-continue">
          <a href="/2016/10/08/not-write-c-parser-part-1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/10/08/exploring-aarch64-assembler-chapter1/">Exploring AArch64 assembler – Chapter 1</a></h1>

        <p class="post-meta">
          Oct 8, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/aarch64/">AArch64</a></p>
      </header>

      <div class="post-content">
        <p>
AArch64 is a new 64 bit mode that is part of the ARMv8 architecture presented in 2011 by ARM. It has been progressively been deployed in smartphones and servers. So I think it is a good moment to learn a bit more about the assembler of this architecture.
</p>

      </div><p class="post-continue">
          <a href="/2016/10/08/exploring-aarch64-assembler-chapter1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/09/05/tiny-gcc-front-part-11/">A tiny GCC front end – Part 11</a></h1>

        <p class="post-meta">
          Sep 5, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a></p>
      </header>

      <div class="post-content">
        <p>
Our tiny language features a few types: <code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code> and arrays of those types. We can even declare new type names based on other types but it still missing a record type. Today we will address this.
</p>

      </div><p class="post-continue">
          <a href="/2016/09/05/tiny-gcc-front-part-11/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/09/04/tiny-gcc-front-part-10/">A tiny GCC front end – Part 10</a></h1>

        <p class="post-meta">
          Sep 4, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a></p>
      </header>

      <div class="post-content">
        <p>
Today we will add a relatively simple feature that will be very useful for a future extension: type declarations.
</p>

      </div><p class="post-continue">
          <a href="/2016/09/04/tiny-gcc-front-part-10/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/31/tiny-gcc-front-part-9/">A tiny GCC front end – Part 9</a></h1>

        <p class="post-meta">
          Jan 31, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a></p>
      </header>

      <div class="post-content">
        <p>
Today we will do something relatively easy: let's add a way to declare boolean variables and express boolean literals.
</p>

      </div><p class="post-continue">
          <a href="/2016/01/31/tiny-gcc-front-part-9/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/30/tiny-gcc-front-part-8/">A tiny GCC front end – Part 8</a></h1>

        <p class="post-meta">
          Jan 30, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a></p>
      </header>

      <div class="post-content">
        <p>
Now that we have the basic language set implemented we can consider adding new features to it. Today we will add arrays.
</p>

      </div><p class="post-continue">
          <a href="/2016/01/30/tiny-gcc-front-part-8/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/19/tiny-gcc-front-part-7/">A tiny GCC front end – Part 7</a></h1>

        <p class="post-meta">
          Jan 19, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a> • <a href="/tags/gcc/">gcc</a>, <a href="/tags/tiny/">tiny</a></p>
      </header>

      <div class="post-content">
        <p>
In this part we will complete the missing statements from part 6 and finish our front end.
</p>


      </div><p class="post-continue">
          <a href="/2016/01/19/tiny-gcc-front-part-7/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/17/tiny-gcc-front-part-6/">A tiny GCC front end – Part 6</a></h1>

        <p class="post-meta">
          Jan 17, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a> • <a href="/tags/gcc/">gcc</a>, <a href="/tags/tiny/">tiny</a></p>
      </header>

      <div class="post-content">
        <p>
In part 5 we described the objects that we will need to semantically analyze a tiny program. In current part we will extend the parser of part 4 to do the semantic analysis and create the GENERIC trees.
</p>


      </div><p class="post-continue">
          <a href="/2016/01/17/tiny-gcc-front-part-6/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/16/tiny-gcc-front-part-5/">A tiny GCC front end – Part 5</a></h1>

        <p class="post-meta">
          Jan 16, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a> • <a href="/tags/gcc/">gcc</a>, <a href="/tags/tiny/">tiny</a></p>
      </header>

      <div class="post-content">
        <p>
In the last installment of this series we saw how to verify that the sequence of tokens of the input is syntactically valid. Today we will see what we need to give it meaning.
</p>

      </div><p class="post-continue">
          <a href="/2016/01/16/tiny-gcc-front-part-5/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/10/tiny-gcc-front-part-4/">A tiny GCC front end – Part 4</a></h1>

        <p class="post-meta">
          Jan 10, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a> • <a href="/tags/gcc/">gcc</a>, <a href="/tags/tiny/">tiny</a></p>
      </header>

      <div class="post-content">
        <p>
Now that we have a stream of tokens we can start performing syntactic analysis.
</p>


      </div><p class="post-continue">
          <a href="/2016/01/10/tiny-gcc-front-part-4/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/08/tiny-gcc-front-part-3/">A tiny GCC front end – Part 3</a></h1>

        <p class="post-meta">
          Jan 8, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a> • <a href="/tags/gcc/">gcc</a>, <a href="/tags/tiny/">tiny</a></p>
      </header>

      <div class="post-content">
        <p>
Now that the minimal infrastructure is already set, we can start with the implementation of our tiny front end. Today we will talk about the lexer.
</p>

      </div><p class="post-continue">
          <a href="/2016/01/08/tiny-gcc-front-part-3/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/06/tiny-gcc-front-part-2/">A tiny GCC front end – Part 2</a></h1>

        <p class="post-meta">
          Jan 6, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a> • <a href="/tags/gcc/">gcc</a>, <a href="/tags/tiny/">tiny</a></p>
      </header>

      <div class="post-content">
        <p>
The previous installment of this series was all about the syntax and the semantics of the tiny language. In this chapter we will start implementing a front end for tiny in GCC. The journey will be long but rewarding. Let's get started.
</p>

      </div><p class="post-continue">
          <a href="/2016/01/06/tiny-gcc-front-part-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2016/01/05/tiny-gcc-front-part-1/">A tiny GCC front end – Part 1</a></h1>

        <p class="post-meta">
          Jan 5, 2016• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a>, <a href="/categories/gcc/">GCC</a> • <a href="/tags/compilers/">compilers</a>, <a href="/tags/frontend/">frontend</a>, <a href="/tags/gcc/">gcc</a>, <a href="/tags/tiny/">tiny</a></p>
      </header>

      <div class="post-content">
        <p>
In this series we will see the process of adding a new front end for a very simple language in GCC. If you, like me, marvel at the magic of compilers then these posts may be for you.
</p>

      </div><p class="post-continue">
          <a href="/2016/01/05/tiny-gcc-front-part-1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/11/20/toying-gcc-jit-part-3/">Toying with GCC JIT – Part 3</a></h1>

        <p class="post-meta">
          Nov 20, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
In the last two parts of this series we've seen how to use GCC JIT and how to apply it to a simple regular expression matcher. But an open question remains, has it been worth the effort? This part will try to figure it out.
</p>

      </div><p class="post-continue">
          <a href="/2015/11/20/toying-gcc-jit-part-3/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/11/18/toying-gcc-jit-part-2/">Toying with GCC JIT – Part 2</a></h1>

        <p class="post-meta">
          Nov 18, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
One of the quintessential UNIX tools is the <code>grep</code> tool. The <q><b>g</b>lobal <b>r</b>egular <b>e</b>xpression <strong>p</strong>rint</q> is a tool that prints lines of text file that match a given regular expression. In this post we will apply JIT compilation to a very simple regular expression matcher by Rob Pike.
</p>

      </div><p class="post-continue">
          <a href="/2015/11/18/toying-gcc-jit-part-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/11/14/toying-gcc-jit-part-1/">Toying with GCC JIT – Part 1</a></h1>

        <p class="post-meta">
          Nov 14, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
A <em>just-in-time</em> (JIT) compiler is a compiler that in contrast to the usual compilers is not run <em>ahead-of-time</em>, i.e. before running the actual program, but during the program itself.
</p>


      </div><p class="post-continue">
          <a href="/2015/11/14/toying-gcc-jit-part-1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/08/17/simple-plugin-gcc-part-3/">A simple plugin for GCC – Part 3</a></h1>

        <p class="post-meta">
          Aug 17, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
In the last chapter, we extended our plugin so it was possible to visualize the control flow graph of a function. In this chapter we will reach our goal to warn unused results of function calls.
</p>

      </div><p class="post-continue">
          <a href="/2015/08/17/simple-plugin-gcc-part-3/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/08/16/simple-plugin-gcc-part-2/">A simple plugin for GCC – Part 2</a></h1>

        <p class="post-meta">
          Aug 16, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
In the last post we set up everything in order to write a GCC plugin. Before we can go on we need to understand a bit how GCC compiles your files.
</p>

      </div><p class="post-continue">
          <a href="/2015/08/16/simple-plugin-gcc-part-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/08/16/a-simple-plugin-for-gcc-part-1/">A simple plugin for GCC – Part 1</a></h1>

        <p class="post-meta">
          Aug 16, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/compilers/">Compilers</a></p>
      </header>

      <div class="post-content">
        <p>
GCC's C and C++ compilers provide several extensions to address several programming needs not covered in the standards. One of these is the <code>warn_unused_result</code> attribute. This attribute warns us that we are discarding the result of a function. Unfortunately, for C++ it does not always work as expected.
</p>

      </div><p class="post-continue">
          <a href="/2015/08/16/a-simple-plugin-for-gcc-part-1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/07/04/arm-assembler-raspberry-pi-chapter-25/">ARM assembler in Raspberry Pi – Chapter 25</a></h1>

        <p class="post-meta">
          Jul 4, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
In chapter 13 we saw VFPv2 and the fact that it allows vectorial operations on floating-point numbers. You may be wondering if such a similar feature exists for integers. The answer is yes although in a more limited way.
</p>


      </div><p class="post-continue">
          <a href="/2015/07/04/arm-assembler-raspberry-pi-chapter-25/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/02/26/array-array/">When an array is not an array</a></h1>

        <p class="post-meta">
          Feb 26, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/uncategorized/">Uncategorized</a> • <a href="/tags/arrays/">arrays</a>, <a href="/tags/c-language/">c language</a>, <a href="/tags/language/">language</a>, <a href="/tags/standard-c/">standard c</a>, <a href="/tags/standardc/">standardc</a></p>
      </header>

      <div class="post-content">
        <p>
The C programming language comes with its own set of <em>warts</em> if we closely examine its syntax and semantics. One of the oddities that puzzles most people is the fact that there are no parameters of array types in C. This fact, though, does not prevent one using the array syntax in a parameter.
</p>

      </div><p class="post-continue">
          <a href="/2015/02/26/array-array/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/01/09/arm-assembler-raspberry-pi-chapter-24/">ARM assembler in Raspberry Pi – Chapter 24</a></h1>

        <p class="post-meta">
          Jan 9, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
Today we will continue with nested functions.
</p>


      </div><p class="post-continue">
          <a href="/2015/01/09/arm-assembler-raspberry-pi-chapter-24/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/01/03/dvd-with-bogus-permissions-ubuntu/">Read DVDs with bogus permissions in Ubuntu</a></h1>

        <p class="post-meta">
          Jan 3, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/linux/">Linux</a> • <a href="/tags/debian/">debian</a>, <a href="/tags/fixes/">fixes</a>, <a href="/tags/opensource/">opensource</a>, <a href="/tags/packages/">packages</a>, <a href="/tags/ubuntu/">ubuntu</a></p>
      </header>

      <div class="post-content">
        <p>
What if your DVD recorder sets bogus permissions to your DVDs?
</p>

      </div><p class="post-continue">
          <a href="/2015/01/03/dvd-with-bogus-permissions-ubuntu/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2015/01/02/arm-assembler-raspberry-pi-chapter-23/">ARM assembler in Raspberry Pi – Chapter 23</a></h1>

        <p class="post-meta">
          Jan 2, 2015• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
Today we will see what happens when we nest a function inside another. It seems a harmless thing to do but it happens to come with its own dose of interesting details.
</p>


      </div><p class="post-continue">
          <a href="/2015/01/02/arm-assembler-raspberry-pi-chapter-23/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2014/12/20/arm-assembler-raspberry-pi-chapter-22/">ARM assembler in Raspberry Pi – Chapter 22</a></h1>

        <p class="post-meta">
          Dec 20, 2014• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a></p>
      </header>

      <div class="post-content">
        <p>
Several times in previous chapters we have talked about ARM as an architecture that has several features aimed at embedding systems. In embedded systems memory is scarce and expensive, so designs that help reduce the memory footprint are very welcome. Today we will see another of these features: the Thumb instruction set.
</p>

      </div><p class="post-continue">
          <a href="/2014/12/20/arm-assembler-raspberry-pi-chapter-22/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2014/08/23/arm-assembler-raspberry-pi-chapter-21/">ARM assembler in Raspberry Pi – Chapter 21</a></h1>

        <p class="post-meta">
          Aug 23, 2014• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
We already know that ARM is a 32-bit architecture: general purpose registers are 32-bit wide and addresses in memory are 32-bit numbers. The natural integer size for an architecture is usually called a <em>word</em> and in ARM is obviously 32-bit integers. Sometimes, though, we need to deal with <em>subword</em> data: integers of size smaller than 32 bits.
</p>

      </div><p class="post-continue">
          <a href="/2014/08/23/arm-assembler-raspberry-pi-chapter-21/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2014/08/20/arm-assembler-raspberry-pi-chapter-20/">ARM assembler in Raspberry Pi – Chapter 20</a></h1>

        <p class="post-meta">
          Aug 20, 2014• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
Today we will see how to make indirect calls.
</p>

      </div><p class="post-continue">
          <a href="/2014/08/20/arm-assembler-raspberry-pi-chapter-20/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2014/05/24/arm-assembler-raspberry-pi-chapter-19/">ARM assembler in Raspberry Pi – Chapter 19</a></h1>

        <p class="post-meta">
          May 24, 2014• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
So far our small assembler programs have output messages using <code>printf</code> and some of them have read input using <code>scanf</code>. These two functions are implemented in the C library, so they are more or less supported in any environment supporting the C language. But how does a program actually communicate with the world?
</p>

      </div><p class="post-continue">
          <a href="/2014/05/24/arm-assembler-raspberry-pi-chapter-19/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2014/05/11/arm-assembler-raspberry-pi-chapter-18/">ARM assembler in Raspberry Pi – Chapter 18</a></h1>

        <p class="post-meta">
          May 11, 2014• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
In this chapter we will delve a bit more into the stack.
</p>

      </div><p class="post-continue">
          <a href="/2014/05/11/arm-assembler-raspberry-pi-chapter-18/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/11/20/arm-assembler-raspberry-pi-chapter-17/">ARM assembler in Raspberry Pi – Chapter 17</a></h1>

        <p class="post-meta">
          Nov 20, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>In chapter 10 we saw the basics to call a function. In this chapter we will cover more topics related to functions.</p>


      </div><p class="post-continue">
          <a href="/2013/11/20/arm-assembler-raspberry-pi-chapter-17/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/08/23/arm-assembler-raspberry-pi-chapter-16/">ARM assembler in Raspberry Pi – Chapter 16</a></h1>

        <p class="post-meta">
          Aug 23, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
We saw in chapters 6 and 12 several control structures but we left out a usual one: the <em>switch</em> also known as <em>select</em>/<em>case</em>. In this chapter we will see how we can implement it in ARM assembler.
</p>

      </div><p class="post-continue">
          <a href="/2013/08/23/arm-assembler-raspberry-pi-chapter-16/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/08/11/arm-assembler-raspberry-pi-chapter-15/">ARM assembler in Raspberry Pi – Chapter 15</a></h1>

        <p class="post-meta">
          Aug 11, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
It may be suprising, but the ARMv6 architecture does not provide an integer division instruction while it does have a floating point instruction in VFPv2. In this chapter we will see usual ways to workaround this limitation with different techniques that can be used in specific scenarios involving divisions.
</p>

      </div><p class="post-continue">
          <a href="/2013/08/11/arm-assembler-raspberry-pi-chapter-15/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/05/12/arm-assembler-raspberry-pi-chapter-14/">ARM assembler in Raspberry Pi – Chapter 14</a></h1>

        <p class="post-meta">
          May 12, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
In chapter 13 we saw the basic elements of VFPv2, the floating point subarchitecture of ARMv6. In this chapter we will implement a floating point matrix multiply using VFPv2.
</p>

      </div><p class="post-continue">
          <a href="/2013/05/12/arm-assembler-raspberry-pi-chapter-14/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/05/12/arm-assembler-raspberry-pi-chapter-13/">ARM assembler in Raspberry Pi – Chapter 13</a></h1>

        <p class="post-meta">
          May 12, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a></p>
      </header>

      <div class="post-content">
        <p>
So far, all examples have dealt with integer values. But processors would be rather limited if they were only able to work with integer values. Fortunately they can work with floating point numbers. In this chapter we will see how we can use the floating point facilities of our Raspberry Pi.
</p>

      </div><p class="post-continue">
          <a href="/2013/05/12/arm-assembler-raspberry-pi-chapter-13/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/03/28/arm-assembler-raspberry-pi-chapter-12/">ARM assembler in Raspberry Pi – Chapter 12</a></h1>

        <p class="post-meta">
          Mar 28, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
We saw in chapter 6 some simple schemes to implement usual structured programming constructs like if-then-else and loops. In this chapter we will revisit these constructs and exploit a feature of the ARM instruction set that we have not learnt yet.
</p>

      </div><p class="post-continue">
          <a href="/2013/03/28/arm-assembler-raspberry-pi-chapter-12/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/03/16/arm-assembler-raspberry-pi-chapter-11/">ARM assembler in Raspberry Pi – Chapter 11</a></h1>

        <p class="post-meta">
          Mar 16, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/branches/">branches</a>, <a href="/tags/function/">function</a>, <a href="/tags/function-call/">function call</a>, <a href="/tags/functions/">functions</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/predication/">predication</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
Several times, in earlier chapters, I stated that the ARM architecture was designed with the embedded world in mind. Although the cost of the memory is everyday lower, it still may account as an important part of the budget of an embedded system. The ARM instruction set has several features meant to reduce the impact of code size. One of the features which helps in such approach is <strong>predication</strong>.
</p>

      </div><p class="post-continue">
          <a href="/2013/03/16/arm-assembler-raspberry-pi-chapter-11/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/02/07/arm-assembler-raspberry-pi-chapter-10/">ARM assembler in Raspberry Pi – Chapter 10</a></h1>

        <p class="post-meta">
          Feb 7, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/function/">function</a>, <a href="/tags/function-call/">function call</a>, <a href="/tags/functions/">functions</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a>, <a href="/tags/stack/">stack</a></p>
      </header>

      <div class="post-content">
        <p>
In chapter 9 we were introduced to functions and we saw that they have to follow a number of conventions in order to play nice with other functions. We also briefly mentioned the stack, as an area of memory owned solely by the function. In this chapter we will go in depth with the stack and why it is important for functions.
</p>

      </div><p class="post-continue">
          <a href="/2013/02/07/arm-assembler-raspberry-pi-chapter-10/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/02/02/arm-assembler-raspberry-pi-chapter-9/">ARM assembler in Raspberry Pi – Chapter 9</a></h1>

        <p class="post-meta">
          Feb 2, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/function/">function</a>, <a href="/tags/function-call/">function call</a>, <a href="/tags/functions/">functions</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
In previous chapters we learnt the foundations of ARM assembler: registers, some arithmetic operations, loads and stores and branches. Now it is time to put everything together and add another level of abstraction to our assembler skills: functions.
</p>


      </div><p class="post-continue">
          <a href="/2013/02/02/arm-assembler-raspberry-pi-chapter-9/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/01/27/arm-assembler-raspberry-pi-chapter-8/">ARM assembler in Raspberry Pi – Chapter 8</a></h1>

        <p class="post-meta">
          Jan 27, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/addresses/">addresses</a>, <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/indexing-modes/">indexing modes</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/postindex/">postindex</a>, <a href="/tags/preindex/">preindex</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
In the previous chapter we saw that the second operand of most arithmetic instructions can use a <em>shift operator</em> which allows us to shift and rotate bits. In this chapter we will continue learning the available <em>indexing modes</em> of ARM instructions. This time we will focus on load and store instructions.
</p>

      </div><p class="post-continue">
          <a href="/2013/01/27/arm-assembler-raspberry-pi-chapter-8/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/01/26/arm-assembler-raspberry-pi-chapter-7/">ARM assembler in Raspberry Pi – Chapter 7</a></h1>

        <p class="post-meta">
          Jan 26, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/indexing-modes/">indexing modes</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
ARM architecture has been for long targeted at embedded systems. Embedded systems usually end being used in massively manufactured products (dishwashers, mobile phones, TV sets, etc). In this context margins are very tight so a designer will always try to spare as much components as possible (a cent saved in hundreds of thousands or even millions of appliances may pay off). One relatively expensive component is memory although every day memory is less and less expensive. Anyway, in constrained memory environments being able to save memory is good and ARM instruction set was designed with this goal in mind. It will take us several chapters to learn all of these techniques, today we will start with one feature usually named <em>shifted operand</em>.
</p>

      </div><p class="post-continue">
          <a href="/2013/01/26/arm-assembler-raspberry-pi-chapter-7/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/01/20/arm-assembler-raspberry-pi-chapter-6/">ARM assembler in Raspberry Pi – Chapter 6</a></h1>

        <p class="post-meta">
          Jan 20, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/control-structures/">control structures</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <h2>Control structures</h2>

<p>
In the previous chapter we learnt branch instructions. They are really powerful tools because they allow us to express control structures. <em>Structured programming</em> is an important milestone in better computing engineering (a foundational one, but nonetheless an important one). So being able to map usual structured programming constructs in assembler, in our processor, is a Good Thing™.
</p>


      </div><p class="post-continue">
          <a href="/2013/01/20/arm-assembler-raspberry-pi-chapter-6/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/01/19/arm-assembler-raspberry-pi-chapter-5/">ARM assembler in Raspberry Pi – Chapter 5</a></h1>

        <p class="post-meta">
          Jan 19, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/branches/">branches</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <h2>Branching</h2>

<p>
Until now our small assembler programs execute one instruction after the other. If our ARM processor were only able to run this way it would be of limited use. It could not react to existing conditions which may require different sequences of instructions. This is the purpose of the <em>branch</em> instructions.
</p>


      </div><p class="post-continue">
          <a href="/2013/01/19/arm-assembler-raspberry-pi-chapter-5/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/01/12/arm-assembler-raspberry-pi-chapter-4/">ARM assembler in Raspberry Pi – Chapter 4</a></h1>

        <p class="post-meta">
          Jan 12, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/debugger/">debugger</a>, <a href="/tags/gdb/">gdb</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
As we advance learning the foundations of ARM assembler, our examples will become longer. Since it is easy to make mistakes, I think it is worth learning how to use GNU Debugger <code>gdb</code> to debug assembler. If you develop C/C++ in Linux and never used <code>gdb</code>, shame on you. If you know <code>gdb</code> this small chapter will explain you how to debug assembler directly.
</p>

      </div><p class="post-continue">
          <a href="/2013/01/12/arm-assembler-raspberry-pi-chapter-4/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/01/11/arm-assembler-raspberry-pi-chapter-3/">ARM assembler in Raspberry Pi – Chapter 3</a></h1>

        <p class="post-meta">
          Jan 11, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/load/">load</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a>, <a href="/tags/store/">store</a></p>
      </header>

      <div class="post-content">
        <p>
We saw in <a href="/2013/01/09/arm-assembler-raspberry-pi-chapter-1/">chapter 1</a> and <a href="/2013/01/10/arm-assembler-raspberry-pi-chapter-2/">chapter 2</a> that we can move values to registers (using <code>mov</code> instruction) and add two registers (using <code>add</code> instruction). If our processor were only able to work on registers it would be rather limited.
</p>

      </div><p class="post-continue">
          <a href="/2013/01/11/arm-assembler-raspberry-pi-chapter-3/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/01/10/arm-assembler-raspberry-pi-chapter-2/">ARM assembler in Raspberry Pi – Chapter 2</a></h1>

        <p class="post-meta">
          Jan 10, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <h2>Registers</h2>

<p>At its core, a processor in a computer is nothing but a powerful calculator. Calculations can only be carried using values stored in very tiny memories called <i>registers</i>. The ARM processor in a Raspberry Pi has 16 integer registers and 32 floating point registers. A processor uses these registers to perform integer computations and floating point computations, respectively. We will put floating registers aside for now and eventually we will get back to them in a future installment. Let’s focus on the integer registers.</p>


      </div><p class="post-continue">
          <a href="/2013/01/10/arm-assembler-raspberry-pi-chapter-2/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2013/01/09/arm-assembler-raspberry-pi-chapter-1/">ARM assembler in Raspberry Pi – Chapter 1</a></h1>

        <p class="post-meta">
          Jan 9, 2013• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/raspberry-pi/">Raspberry Pi</a> • <a href="/tags/arm/">arm</a>, <a href="/tags/assembler/">assembler</a>, <a href="/tags/pi/">pi</a>, <a href="/tags/raspberry/">raspberry</a></p>
      </header>

      <div class="post-content">
        <p>
In my opinion, it is much more beneficial learning a high level language than a specific architecture assembler. But I fancied learning some ARM assembler just for fun since I know some 386 assembler. The idea is not to become a master but understand some of the details of what happens underneath.
</p>

      </div><p class="post-continue">
          <a href="/2013/01/09/arm-assembler-raspberry-pi-chapter-1/">Read on &rarr;</a>
        </p></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2012/08/08/common-linking-issues-c/">Common linking issues in C++</a></h1>

        <p class="post-meta">
          Aug 8, 2012• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/uncategorized/">Uncategorized</a></p>
      </header>

      <div class="post-content">
        <h2>Introduction</h2>

<p>
C++ is a language derived from C, so in essence all problems at link time boil down at declaring stuff but not defining it.
</p>

<p>
Declaring something in C++ means bringing the entity into existence in the program, so it can be used after the declaration point.  Defining something means giving a complete description of the entity itself.  You can declare a class or a function, and it means this class and this function do exist. But to completely describe a class and a function you have to define them. A class definition provides a list of base classes of that class, a list of members (data members and member functions) of that class, etc.  A function definition provides the executable code of that function. All definitions are declarations but not all declarations are definitions.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="c1">// Defines variable 'x'</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// Declares variable 'y'</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="c1">// Declares class 'A'</span>
<span class="k">struct</span> <span class="nc">A</span><span class="p">;</span>
<span class="c1">// Declares function 'f(int)'</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

<span class="c1">// Defines class 'A'</span>
<span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="c1">// Declares member function 'A::g(float)'</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>

    <span class="c1">// Defines member function 'A::h(char)'</span>
    <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> 
    <span class="p">{</span> 
      <span class="c1">// Code</span>
    <span class="p">}</span>

    <span class="c1">// Defines data member 'A::x'</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

    <span class="c1">// Declares static data member 'A::y'</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Defines  function'f(int)'</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
 <span class="c1">// Code</span>
<span class="p">}</span>

<span class="c1">// Defines member function 'A::g(float)'</span>
<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">g</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span>
<span class="p">{</span>
 <span class="c1">// Code</span>
<span class="p">}</span>

<span class="c1">// Defines static data member 'A::y'</span>
<span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">y</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
C++, in contrast to C, strongly sticks to the One Definition Rule which states that entities can be defined at most once in an entire program. Of course this may not be completely true depending your own the definition of "entity": template functions when instantiated by the compiler can be defined more than once in the program, and some magic happens so this does not become a problem.
</p>

<p>
Anyway, C++ brings its own set of linking issues which may fool even the most experienced C++ developer.
</p>

<h2>Static data members are only declared inside the class specifier</h2>

<p>
Some might argue that this is one of the most common source of linking issues when using C++. Truth be told, static data members are just global variables in disguise so most people will avoid them. However, there are cases where a static data member may come in handy, for instance when implementing the singleton pattern.
</p>

<p>
The problem lies that, although usual (nonstatic) data members are defined when they are declared inside a class (like in line 23 of the example above), static data members are only declared.  Thus in line 26 of the example above <code>A::y</code> is only being declared.  Its actual definition is given in line 42. The actual definition of a static data member will go in the implementation file (usually a <code>.cpp</code> or <code>.cc</code> file).
</p>

<p>
So the usual case goes like this: you realize you need a static data member. You add it to the class. Your code compiles fine but does not link. In fact 'A::y', the static data member you just added is undefined? How can this be? 
</p>

<p>
Now you know the reason.
</p>

<p>
What is the reason this issue is hit so many times? Well, there are three reasons. A historical one, where early versions of C++ compilers allowed this. A quirk in the C++ language itself where <code>const</code> integral and enumerator static data members can be declared and initialized in the class itself (thus defining them as well). And finally, a <q>linguistic</q> issue, since in Java and C# static fields are declared like any other fields plus a <code>static</code> specifier.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="c1">// -- Header file</span>
<span class="k">class</span> <span class="nc">MySingleton</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">MySingleton</span><span class="o">&amp;</span> <span class="n">getInstance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">singleton_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">singleton_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MySingleton</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">singleton_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="c1">// Usual private constructor</span>
    <span class="n">MySingleton</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// Declaration</span>
    <span class="k">static</span> <span class="n">MySingleton</span> <span class="o">*</span><span class="n">singleton_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// -- Implementation file</span>
<span class="c1">// Definition</span>
<span class="n">MySingleton</span><span class="o">*</span> <span class="n">MySingleton</span><span class="o">::</span><span class="n">singleton_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2>Not all headers are created equal</h2>

<p>
The usual myth is that C++ is a superset of C. Well, it looks like as a superset of C but they are actually two different languages. That said, they share so many thinks that interfacing C++ and C is pretty straightforward, in particular when the former must call the latter (the opposite may be a bit more challenging).
</p>

<p>
Thus, it is not unsual to see that a C++ program <code>#include</code>s C header files. Chances are that the headers of your operating system will be in C. Being able to #include a C header and using the entities declared in it is one of the strengths of C++. And this is the source of our second problem.
</p>

<p>
Remember that in C++ functions may be overloaded. This means that we can use the same name when declaring two functions in the same scope as long as they have different enough parameter types.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="c1">// Declaration of 'f(int)'</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="c1">// Declaration of 'f(float)'</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
<span class="c1">// Redeclaration of 'f(int)' since, in a parameter, 'const int' cannot</span>
<span class="c1">// be distinguished from 'int'</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
It may be non obvious, but we cannot give these two functions declared above the same <code>f</code> name.  So the compiler crafts an artificial name for <code>f(int)</code> and <code>f(float)</code> (this is called a decorated name or a mangled name). For instance they could be <code>f_1_int</code> and <code>f_1_float</code> (here 1 would mean the number of parameters). The C++ compiler will internally use these names when generating code and the lower levels will just see two diferent names.
</p>

<p>
But overloading cannot be applied to C. Thus we run into a problem here. If we <code>#include</code> C headers, the names of these functions cannot be overloaded thus a C compiler will generated code using the (undecorated) name of the function.  If our C++ compiler always uses a decorated name, there will be an unresolved symbol. The C++ compiler cannot tell if this is C or C++.  Can it?
</p>

<p>
Good news, it can. You can define the linkage of declarations in the code. By default linkage is <code>C++</code> so overload works as described above. When you want to <code>#include</code> a C header, you will have to tell the C++ compiler that the linkage of the declarations is C, not C++. Most of the time you will find these lines in the beginning of a C header intended to be used from C++.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="c1">// Remember this is a C header so protect ourselves when this is compiled using C</span>
<span class="cp">#ifdef __cplusplus 
</span><span class="c1">// This 'extern "C"' syntax is only valid in C++, not in C.</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span> 
<span class="c1">// From now everything has C linkage. </span>
<span class="cp">#endif
</span>
<span class="cm">/* Library declarations in C */</span>

<span class="cp">#ifdef __cplusplus 
</span><span class="c1">// Close the brace opened above</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2>Virtual member functions and virtual tables</h2>

<p>
Finally one of the, in my opinion, most confusing link errors when using a C++ compilers: virtual table unresolved references.
</p>

<p>
Virtual member functions are, in C++ parlance, polymorphic methods of other programming languages (like Java). Virtual member functions can be overridden by derived classes (descendant classes) thus when called, they must be dispatched dinamically.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">vmf</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">vmf2</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">B</span> <span class="o">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">vmf</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">vmf3</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">virtual</span> <span class="n">B</span><span class="o">::</span><span class="n">vmf</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Code</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">pfl</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Dynamic dispatch </span>
  <span class="c1">// we don't really know if A::vmf or B::vmf will be called</span>
  <span class="n">pa</span><span class="o">-&gt;</span><span class="n">vmf</span><span class="p">(</span><span class="n">pfl</span><span class="p">);</span>

  <span class="c1">// Static call to A::vmf since we qualified the function being called</span>
  <span class="n">pa</span><span class="o">-&gt;</span><span class="n">A</span><span class="o">::</span><span class="n">vmf</span><span class="p">(</span><span class="n">pfl</span><span class="p">);</span>

  <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
  <span class="c1">// Static call to B::vmf, no doubts here since the dynamic type (in memory)</span>
  <span class="c1">// of 'b' and its declared type must be the same</span>
  <span class="n">b</span><span class="p">.</span><span class="n">vmf</span><span class="p">(</span><span class="n">pfl</span><span class="p">);</span>

  <span class="n">A</span><span class="o">&amp;</span> <span class="n">ra</span><span class="p">(</span><span class="o">*</span><span class="n">pa</span><span class="p">);</span>
  <span class="c1">// Dynamic dispatch again</span>
  <span class="n">ra</span><span class="p">.</span><span class="n">vmf</span><span class="p">(</span><span class="n">pfl</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
Dynamic dispatch is implemented using a virtual method table (or vtable).  Every class with virtual methods (called a dynamic class) has a vtable.  This vtable is a sequence of addresses to member functions. Every virtual member function is assigned an index in this table and the addresses points to the function implementing the virtual member function for that class. For instance class <code>A</code> above has two member functions <code>vmf</code> and <code>vmf2</code>. The vtable of <code>A</code>, then will have two entries, 0 and 1, and will point to the functions <code>A::vmf</code> and <code>A::vmf2</code> respectively. The vtable of <code>B</code> will have three entries, 0, 1, 2, that will point to functions <code>B::vmf</code>, <code>A::vmf2</code> and <code>B::vmf3</code> respectively.
</p>

<p>
Every object of a dynamic class has a hidden data member (called the virtual pointer) that points to the vtable of its class. When C++ specifies that a call goes through dynamic dispatch (in C++ parlance, a call to the ultimate overrider), we do not call directly any function but instead, through this hidden data member, we reach the vtable and using the index of the virtual member function being called, we retrieve the entry containing the addresses to the real function. Then this addresses is used in an indirect call.
</p>

<p>
Since both the virtual table and the virtual pointer are hidden from the eyes of the developer, sometimes errors in our code may cause link errors.
</p>

<h3>The compiler does not emit a vtable</h3>

<p>
This may not apply to all C++ compilers, but usually a C++ compiler only emits a vtable when it finds a definition of a virtual member function. Note that virtual member function definitions for a given class may be scattered in several files. Magic happens again so more than one definition of the vtable of a given class in several files does not become a problem at link time.
</p>

<p>
But, what if you forget to define all virtual functions? This may look contrived but in my experience this may happen by accident. The problem lies on the error at link time, which is really confusing.
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x_</span><span class="p">;</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// We forget to define A::foo</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">quux</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Dynamic dispatch</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">quux</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
If you compile and link this with g++ (I use <code>-g</code> since it improves link error messages by using the debugging information).
</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">$ g++ -o prova test.cc -g
/tmp/ccl71r2A.o: In function `A':
test.cc:4: undefined reference to `vtable for A'
collect2: ld returned 1 exit status</code></pre></figure>

<p>
But the line 4 is the constructor. You see now how confusing this message is, don't you? What is going on?
</p>

<p>
Well, everything makes sense if we remember that hidden data member I mentioned above, the virtual pointer. As a data member of a class it must be initialized in the constructor. It is initialized with the address of the virtual table of A. But the virtual table of A was not emitted since we forgot to define <strong>all</strong> virtual member functions. Thus, unresolved reference for the virtual table.  
</p>

<h3>Missing virtual member functions in base classes</h3>

<p>
Remember that the vtable contains entries for all the virtual member functions of the base tables. The vtable is statically initialized (this is, the compiler "hardcodes" in the generated code, in the data section) the addresses of each entry. What if we forget to define a virtual member function of a base class?
</p>

<p>
Consider this example
</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x_</span><span class="p">;</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
    <span class="c1">// We forget to define A::foo2</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo2</span><span class="p">();</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="c1">// Definition of A::foo</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">B</span> <span class="o">:</span> <span class="n">A</span> 
<span class="p">{</span>
    <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> 
    <span class="p">{</span> 
        <span class="c1">// Definition of B::foo</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">quux</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">quux</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>
If we compile and link with g++ we get
</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">/tmp/cc4t9NG3.o:(.rodata._ZTV1B[vtable for B]+0xc): undefined reference to `A::foo2()'
/tmp/cc4t9NG3.o:(.rodata._ZTV1A[vtable for A]+0xc): undefined reference to `A::foo2()'
collect2: ld returned 1 exit status</code></pre></figure>

<p>
This happens because vtables of <code>A</code> and <code>B</code> refer to <code>A::foo2</code>, but we forgot to define it. Fortunately, now the error message is easier to grasp: some function is missing.
</p>

<p>
Obviously, many more link errors caused by C++ exist, but I think the ones shown here are quite common and the error messages related to them are quite confusing.
</p>

      </div></li><li>
      <header class="post-header">
        <h1 class="post-title"><a class="post-link" href="/2012/07/29/crazy-stuff-c-1/">Crazy stuff in C++ (1)</a></h1>

        <p class="post-meta">
          Jul 29, 2012• <span itemprop="author" itemscope="" itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/uncategorized/">Uncategorized</a> • <a href="/tags/classes/">classes</a>, <a href="/tags/cplusplus/">cplusplus</a>, <a href="/tags/functions/">functions</a>, <a href="/tags/specializations/">specializations</a>, <a href="/tags/templates/">templates</a></p>
      </header>

      <div class="post-content">
        <h2>Introduction</h2>
<p>C++ is a controversial language: you love it or you hate it. As always, knowing better about something allows one to make better arguments for or against that thing. This is what this series is about. Here I’ll explain some of the less known (except for C++ expert programmers, of course) features of C++.</p>

<p>Let’s start with templates, which account for such a huge part of the language.</p>
<h2>Templates</h2>
<p>Everyone knows that C++ has templates. Templates is an implementation of the «I have an algorithm that can be used with many different types» idea. This idea is called <a title="generic programming" href="http://en.wikipedia.org/wiki/Generic_programming" target="_blank">generic programming</a> and is a pretty powerful one. This is why it is present in almost all modern languages.</p>

<p>Back to C++. C++ defines two kinds of templates: <em>classes templates</em> and <em> function templates</em>. Class templates define an infinite set of classes while function templates define an infinite set of functions. The elements of these sets of classes or functions are called <em>specializations</em>. Every template has a <em>template-name</em> which will be used to name a specific specialization.</p>
<h3>Template declarations</h3>
<p>Consider these two declarations</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">my_list</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">max</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>These are <em>template declarations</em>. The first one declares a class template and its template-name is <em>my_list</em>, the second one defines a function template and its template-name is <em>max</em>. A template declaration is just a declaration preceded with something without an official name that starts with <em>template &lt;…&gt;</em>, I will call it the <em>template header</em> (but note that this name is not blessed by the C++ standard at all, it just makes sense to me call it like this).</p>

<p>The template header defines what are the parameters of the template class. These are called the <em>template parameters</em>. A <em>type-template parameter</em>, like that <em>T</em> shown above, is a “type variable”. This is the most usual template parameter as it allows to parameterize the declaration over one or more type variables. C++, though, has two more kinds of template parameters:<em> nontype-template parameters</em> and (the funny named) <em>template-template parameter</em>. A nontype-template parameter allows us to parameterize the declaration over a (compile-time) constant integer value. Here “integer value” is a very broad term: of course it includes all integers, but also enum values (enumerators) and addresses of (statically allocated) variables and functions. A template-template parameter allows us to parameterize a declaration over another class template with appropiate template parameters.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span> <span class="c1">// N is a nontype-template parameter</span>
<span class="k">struct</span> <span class="nc">my_fixed_array</span> <span class="p">{</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="n">MyContainer</span><span class="p">&gt;</span> <span class="c1">// MyContainer is a template-template parameter</span>
<span class="k">struct</span> <span class="nc">adaptor</span> <span class="p">{</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2>Specializations</h2>
<p>I said above that a class template or function template defines an infinite set of classes or function and that each element of that set was called a specialization. There is a specialization for every possible value that a template parameter can have. Such values are not bounded thus there is an infinite number of specializations (well, we could argue that constant integer values are finite in the language, but types are clearly not finite).</p>

<p>We give value to template parameters of a template by means of <em>template arguments</em>. These template arguments always appear in what is called a <em>template-id</em>. A template-id is just the template-name followed by a list of template-arguments enclosed in &lt; and &gt;.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">my_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span><span class="c1">// Here T has value int, we will write it as T ← int</span>
<span class="n">max</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">3.4</span><span class="n">f</span><span class="p">,</span> <span class="mf">5.6</span><span class="n">f</span><span class="p">);</span> <span class="c1">// T ← float</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3>Primary template and partial specializations</h3>
<p>When we first declare a class template or a function template, such declaration defines the <em>primary template</em>.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">my_list</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Class templates (but not function templates!) can have an extra set of template declarations called <em>partial specializations</em>. A partial specialization looks like a normal class template declaration but the template-name is now a template-id where the template-arguments partially specialize the given template parameters.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="c1">// 1) Partial specialization for "pointer to (any) P" type</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">P</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">my_list</span><span class="o">&lt;</span><span class="n">P</span><span class="o">*&gt;</span> <span class="p">{</span> <span class="p">};</span> 

<span class="c1">// 2) Partial specialization for "array of (any) Size of (any) Element"</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Element</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Size</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">my_list</span><span class="o">&lt;</span><span class="n">Element</span><span class="p">[</span><span class="n">Size</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">};</span>

<span class="c1">// 3) Partial specialization for "pointer to function with two parameters </span>
<span class="c1">// Arg1 and Arg2 returning Ret"</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Ret</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Arg1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Arg2</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">my_list</span><span class="o">&lt;</span><span class="n">Ret</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Arg1</span><span class="p">,</span> <span class="n">Arg2</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>A C++ compiler will always pick the partial specialization (if any) that is “closer” to the one requested in the template arguments. If no partial specialization matches, the primary template is chosen instead. The exact algorithm is not important here.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="n">my_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l0</span><span class="p">;</span> <span class="c1">// will pick the primary template T ← int</span>

<span class="n">my_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">l1</span><span class="p">;</span> <span class="c1">// will pick partial specialization 1) </span>
<span class="c1">// where P ← int (note that respect to the primary template this is T ← int*)</span>

<span class="n">my_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">l2</span><span class="p">;</span> <span class="c1">// will pick partial specialization 2) </span>
<span class="c1">// where Element ← int and Size ← 10</span>

<span class="n">my_list</span><span class="o">&lt;</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">float</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">l3</span><span class="p">;</span> <span class="c1">// will pick partial specialization 3) </span>
<span class="c1">// where Ret ← int, Arg1 ← float and Arg2 ← double</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>I think this is enough for today regarding C++ templates. More craziness to come. Stay tuned.</p>

      </div></li></ul>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Powered by <a href="https://jekyllrb.com">Jekyll</a>. Theme based on <a href="https://github.com/yous/whiteglass">whiteglass</a>
<br>
Subscribe via <a href="https://thinkingeek.com/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
