<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Writing GObjects in C++</title>
  <meta name="description" content="In the last post I discussed about how glibmm, the wrapper of the GLib library exposes GObjects and we finished about a rationale about why one would want to write full-fledged GObjects in C++. Today we are exploring this venue and observing some of the pain points we are going to face.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://thinkingeek.com/2023/02/04/writing-gobjects-in-cpp/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Think In Geek" href="https://thinkingeek.com/feed.xml">

  

  
  <meta property="og:title" content="Writing GObjects in C++">
  <meta property="og:site_name" content="Think In Geek">
  <meta property="og:url" content="https://thinkingeek.com/2023/02/04/writing-gobjects-in-cpp/">
  <meta property="og:description" content="In the last post I discussed about how glibmm, the wrapper of the GLib library exposes GObjects and we finished about a rationale about why one would want to write full-fledged GObjects in C++. Today we are exploring this venue and observing some of the pain points we are going to face.">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Writing GObjects in C++">
  <meta name="twitter:description" content="In the last post I discussed about how glibmm, the wrapper of the GLib library exposes GObjects and we finished about a rationale about why one would want to write full-fledged GObjects in C++. Tod...">
  
  

  <link rel="stylesheet" href="/assets/fonts/fonts.css">

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

      <span class="site-title"><a href="/">Think In Geek</a> | </span>
      <span class="site-slogan">In geek we trust</span>

    <nav class="site-nav"><a class="page-link" href="/series/">Series</a><a class="page-link" href="/author/brafales/">Posts by Bernat Ràfales</a><a class="page-link" href="/archives/">Archives</a></nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Writing GObjects in C++</h1>
    
    <p class="post-meta"><time datetime="2023-02-04T21:46:00+00:00" itemprop="datePublished">Feb 4, 2023</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Roger Ferrer Ibáñez</span></span> • <a href="/categories/gtk/">gtk</a>, <a href="/categories/gobject/">gobject</a>, <a href="/categories/gnome/">gnome</a>, <a href="/categories/cpp/">cpp</a>, <a href="/categories/cplusplus/">cplusplus</a></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>In the last post I discussed about how glibmm, the wrapper of the GLib
library exposes GObjects and we finished about a rationale about why
one would want to write full-fledged GObjects in C++.</p>

<p>Today we are exploring this venue and observing some of the pain points
we are going to face.</p>

<!--more-->

<h1>Quick recap</h1>

<p>GLib is the foundational library on which other technologies like the GTK GUI
toolkit or many components of the GNOME Desktop environment software stack
build upon.  GLib contains GObject, a dynamic type system that implements a
more or less classical OOP paradigm. GLib is written in C and
<a href="https://gitlab.gnome.org/GNOME/glibmm">glibmm</a> is the C++ wrapper of GLib.</p>

<p>GObject type system exposes classes and instances (objects) of classes as
normal C data. Mostly for ergonomic reasons, glibmm focuses on the (GObject)
instances and does not expose as much the (GObject) classes. This means that
our C++ classes will be used to implement behaviour of (GObject) instances and
not so much behaviour of (GObject) classes.</p>

<p>We need a full fledged GObject if we want it to interact with other components
in the GTK/GNOME Desktop stack. In particular I’m interested in being able
to use those C++-written GObjects in <code class="language-plaintext highlighter-rouge">.ui</code> files that describe interfaces.</p>

<h1>Current approach</h1>

<p>Let’s see a simplified version of the <a href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/-/tree/b5614081b11077173d80b40d56ba96742e88a430/examples/book/builder/derived">example</a> in the gtkmm book
on how to use using derived widgets and <code class="language-plaintext highlighter-rouge">.ui</code> files.</p>

<p>First lets define a very simple interface made up of an application
window that includes a box container which has our derived button.</p>

<figure class="highlight"><figcaption>derived.ui</figcaption><pre><code class="language-xml" data-lang="xml"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;interface&gt;</span>
  <span class="nt">&lt;object</span> <span class="na">class=</span><span class="s">"GtkApplicationWindow"</span> <span class="na">id=</span><span class="s">"WindowDerived"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"can_focus"</span><span class="nt">&gt;</span>False<span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"title"</span> <span class="na">translatable=</span><span class="s">"yes"</span><span class="nt">&gt;</span>Derived Builder example<span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"default_width"</span><span class="nt">&gt;</span>150<span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"default_height"</span><span class="nt">&gt;</span>100<span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hide_on_close"</span><span class="nt">&gt;</span>True<span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;child&gt;</span>
      <span class="nt">&lt;object</span> <span class="na">class=</span><span class="s">"GtkBox"</span> <span class="na">id=</span><span class="s">"dialog-vbox2"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"orientation"</span><span class="nt">&gt;</span>vertical<span class="nt">&lt;/property&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"valign"</span><span class="nt">&gt;</span>center<span class="nt">&lt;/property&gt;</span>
        <span class="nt">&lt;child</span> <span class="na">type=</span><span class="s">"end"</span><span class="nt">&gt;</span>
          <span class="nt">&lt;object</span> <span class="na">class=</span><span class="s">"gtkmm__CustomObject_MyButton"</span> <span class="na">id=</span><span class="s">"quit_button"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"halign"</span><span class="nt">&gt;</span>center<span class="nt">&lt;/property&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"label"</span><span class="nt">&gt;</span>Quit<span class="nt">&lt;/property&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"button-ustring"</span><span class="nt">&gt;</span>Button with extra properties<span class="nt">&lt;/property&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"button-int"</span><span class="nt">&gt;</span>85<span class="nt">&lt;/property&gt;</span>
          <span class="nt">&lt;/object&gt;</span>
        <span class="nt">&lt;/child&gt;</span>
      <span class="nt">&lt;/object&gt;</span>
    <span class="nt">&lt;/child&gt;</span>
  <span class="nt">&lt;/object&gt;</span>
<span class="nt">&lt;/interface&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Line 14 of <code class="language-plaintext highlighter-rouge">derived.ui</code> refers to our custom button class. Because it inherits
from a Gtk.Button it inherits its properties such as <code class="language-plaintext highlighter-rouge">label</code> or <code class="language-plaintext highlighter-rouge">halign</code> (which
is actually inherited from Gtk.Widget). We will define our own custom properties
<code class="language-plaintext highlighter-rouge">button-ustring</code> and <code class="language-plaintext highlighter-rouge">button-int</code> whose initial values are set to the values
in the XML file (<code class="language-plaintext highlighter-rouge">"Button with extra properties"</code> and <code class="language-plaintext highlighter-rouge">85</code>, respectively).</p>

<h2>Custom button with extra properties</h2>

<p>Let’s define now our custom button.</p>

<figure class="highlight"><figcaption>derivedbutton.h</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="cp">#ifndef DERIVED_BUTTON_H
#define DERIVED_BUTTON_H
</span>
<span class="cp">#include</span> <span class="cpf">&lt;gtkmm.h&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">DerivedButton</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Button</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">DerivedButton</span><span class="p">();</span>
  <span class="n">DerivedButton</span><span class="p">(</span><span class="n">BaseObjectType</span> <span class="o">*</span><span class="n">cobject</span><span class="p">,</span> <span class="k">const</span> <span class="n">Glib</span><span class="o">::</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">DerivedButton</span><span class="p">();</span>

  <span class="n">Glib</span><span class="o">::</span><span class="n">PropertyProxy</span><span class="o">&lt;</span><span class="n">Glib</span><span class="o">::</span><span class="n">ustring</span><span class="o">&gt;</span> <span class="n">property_ustring</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">prop_ustring</span><span class="p">.</span><span class="n">get_proxy</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">Glib</span><span class="o">::</span><span class="n">PropertyProxy</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">property_int</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prop_int</span><span class="p">.</span><span class="n">get_proxy</span><span class="p">();</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Glib</span><span class="o">::</span><span class="n">Property</span><span class="o">&lt;</span><span class="n">Glib</span><span class="o">::</span><span class="n">ustring</span><span class="o">&gt;</span> <span class="n">prop_ustring</span><span class="p">;</span>
  <span class="n">Glib</span><span class="o">::</span><span class="n">Property</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prop_int</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">on_ustring_changed</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">on_int_changed</span><span class="p">();</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Here we define our two custom properties and we define proxies for them. Proxies
will allow us to connect the signal that is emitted when the property changes.</p>

<p>Constructors at lines 8 and 9 deserve some explanation, but first let’s see
the implementation of the class.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">"derivedbutton.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// For creating a dummy object in main.cc.</span>
<span class="n">DerivedButton</span><span class="o">::</span><span class="n">DerivedButton</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">Glib</span><span class="o">::</span><span class="n">ObjectBase</span><span class="p">(</span><span class="s">"MyButton"</span><span class="p">),</span> <span class="n">prop_ustring</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="s">"button-ustring"</span><span class="p">),</span>
      <span class="n">prop_int</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="s">"button-int"</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">on_ustring_changed</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- ustring property changed! new val "</span> <span class="o">&lt;&lt;</span> <span class="n">property_ustring</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">on_int_changed</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- int property changed! new val "</span> <span class="o">&lt;&lt;</span> <span class="n">property_int</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DerivedButton</span><span class="o">::</span><span class="n">DerivedButton</span><span class="p">(</span><span class="n">BaseObjectType</span> <span class="o">*</span><span class="n">cobject</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Glib</span><span class="o">::</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Glib</span><span class="o">::</span><span class="n">ObjectBase</span><span class="p">(</span><span class="s">"MyButton"</span><span class="p">),</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Button</span><span class="p">(</span><span class="n">cobject</span><span class="p">),</span>
      <span class="n">prop_ustring</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="s">"button-ustring"</span><span class="p">),</span> <span class="n">prop_int</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="s">"button-int"</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">property_ustring</span><span class="p">().</span><span class="n">signal_changed</span><span class="p">().</span><span class="n">connect</span><span class="p">(</span>
      <span class="n">sigc</span><span class="o">::</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">on_ustring_changed</span><span class="p">));</span>
  <span class="n">property_int</span><span class="p">().</span><span class="n">signal_changed</span><span class="p">().</span><span class="n">connect</span><span class="p">(</span>
      <span class="n">sigc</span><span class="o">::</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">on_int_changed</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">DerivedButton</span><span class="o">::~</span><span class="n">DerivedButton</span><span class="p">()</span> <span class="p">{}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The constructor at line 5 is a dummy constructor that we will need later, when
initialising the application (or widget library). We need it because GLib
distinguishes the registering of a class type in the type system and the
instantiation of objects of such type as two different steps. However, glibmm
combines both, so we need to make sure the class type exists before we can use
it generically from GLib or other libraries using GObject. The only way to do
this in glibmm is to instantiate a C++ object of the C++ class wrapping
the GObject class.</p>

<p>Unfortunately, this also means that any other constructor needs to behave the
same when it comes to registering the class type. So the constructor at line 19
needs to initialise <code class="language-plaintext highlighter-rouge">Glib::ObjectBase</code> and the properties in the same way, to
avoid unexpected inconsistencies. This constructor also has to propagate the C
object (<code class="language-plaintext highlighter-rouge">cobject</code>) to the parent constructor. This object has been generically
built using generic GObject machinery and so we are actually wrapping an object
that already exists (i.e. the GObject instance does not exist because we
instantiated the class <code class="language-plaintext highlighter-rouge">DerivedButton</code> which is another possible scenario).</p>

<h2>Main window</h2>

<p>Now let’s look at the main window. This is not a custom widget because
we won’t be defining new properties for it. However in C++ we will create
a subclass for it as well.</p>

<figure class="highlight"><figcaption>derivedwindow.h</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="cp">#ifndef DERIVED_WINDOW_H
#define DERIVED_WINDOW_H
</span>
<span class="cp">#include</span> <span class="cpf">"derivedbutton.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;gtkmm.h&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">DerivedWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">ApplicationWindow</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">DerivedWindow</span><span class="p">(</span><span class="n">BaseObjectType</span> <span class="o">*</span><span class="n">cobject</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">Glib</span><span class="o">::</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">DerivedWindow</span><span class="p">();</span>

<span class="nl">protected:</span>
  <span class="c1">// Signal handlers:</span>
  <span class="kt">void</span> <span class="n">on_button_quit</span><span class="p">();</span>

  <span class="n">Glib</span><span class="o">::</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="n">m_builder</span><span class="p">;</span>
  <span class="n">DerivedButton</span> <span class="o">*</span><span class="n">m_pButton</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Line 9 contains a constructor that again, wraps a GObject instance that
will be created elsewhere. Parameter <code class="language-plaintext highlighter-rouge">builder</code> is a reference to Gtk.Builder
which is an object used to create interfaces from <code class="language-plaintext highlighter-rouge">.ui</code> files.</p>

<figure class="highlight"><figcaption>derivedwindow.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">"derivedwindow.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="n">DerivedWindow</span><span class="o">::</span><span class="n">DerivedWindow</span><span class="p">(</span><span class="n">BaseObjectType</span> <span class="o">*</span><span class="n">cobject</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Glib</span><span class="o">::</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">ApplicationWindow</span><span class="p">(</span><span class="n">cobject</span><span class="p">),</span> <span class="n">m_builder</span><span class="p">(</span><span class="n">builder</span><span class="p">),</span>
      <span class="n">m_pButton</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Get the Gtk.Builder-instantiated Button, and connect a signal handler:</span>
  <span class="n">m_pButton</span> <span class="o">=</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">::</span><span class="n">get_widget_derived</span><span class="o">&lt;</span><span class="n">DerivedButton</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m_builder</span><span class="p">,</span>
                                                              <span class="s">"quit_button"</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m_pButton</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_pButton</span><span class="o">-&gt;</span><span class="n">signal_clicked</span><span class="p">().</span><span class="n">connect</span><span class="p">(</span>
        <span class="n">sigc</span><span class="o">::</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DerivedWindow</span><span class="o">::</span><span class="n">on_button_quit</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">DerivedWindow</span><span class="o">::~</span><span class="n">DerivedWindow</span><span class="p">()</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">DerivedWindow</span><span class="o">::</span><span class="n">on_button_quit</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// set_visible(false) will cause Gtk::Application::run() to end.</span>
  <span class="n">set_visible</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The implementation is pretty straightforward, we wrap the created gobject
and we keep a reference to the Gtk.Builder we receive. Then we use the builder
instance to obtain our derived button. If all goes well we connect the <code class="language-plaintext highlighter-rouge">clicked</code>
signal so it hides the dialog. We will use this later to quit the application.</p>

<h2>Main application</h2>

<p>The only last piece remaining is the entry point to our application.</p>

<figure class="highlight"><figcaption>main.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">"derivedwindow.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="p">{</span>

<span class="n">DerivedWindow</span> <span class="o">*</span><span class="n">pWindow</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="n">Glib</span><span class="o">::</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Application</span><span class="o">&gt;</span> <span class="n">app</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">on_app_activate</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Create a dummy instance before the call to refBuilder-&gt;add_from_file().</span>
  <span class="c1">// This creation registers DerivedButton's class in the GObject type system.</span>
  <span class="c1">// This is necessary because DerivedButton contains user-defined properties</span>
  <span class="c1">// (Glib::Property) and is created by Gtk::Builder.</span>
  <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">DerivedButton</span><span class="p">());</span>

  <span class="c1">// Load the GtkBuilder file and instantiate its widgets:</span>
  <span class="k">auto</span> <span class="n">refBuilder</span> <span class="o">=</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">refBuilder</span><span class="o">-&gt;</span><span class="n">add_from_file</span><span class="p">(</span><span class="s">"derived.ui"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Error while loading .ui file</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Get the GtkBuilder-instantiated dialog:</span>
  <span class="n">pWindow</span> <span class="o">=</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">::</span><span class="n">get_widget_derived</span><span class="o">&lt;</span><span class="n">DerivedWindow</span><span class="o">&gt;</span><span class="p">(</span><span class="n">refBuilder</span><span class="p">,</span>
      <span class="s">"WindowDerived"</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pWindow</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Could not get the dialog"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// It's not possible to delete widgets after app-&gt;run() has returned.</span>
  <span class="c1">// Delete the dialog with its child widgets before app-&gt;run() returns.</span>
  <span class="n">pWindow</span><span class="o">-&gt;</span><span class="n">signal_hide</span><span class="p">().</span><span class="n">connect</span><span class="p">([]()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">pWindow</span><span class="p">;</span> <span class="p">});</span>

  <span class="n">app</span><span class="o">-&gt;</span><span class="n">add_window</span><span class="p">(</span><span class="o">*</span><span class="n">pWindow</span><span class="p">);</span>
  <span class="n">pWindow</span><span class="o">-&gt;</span><span class="n">set_visible</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// anonymous namespace</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">app</span> <span class="o">=</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Application</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="s">"org.gtkmm.example"</span><span class="p">);</span>

  <span class="c1">// Instantiate a dialog when the application has been activated.</span>
  <span class="c1">// This can only be done after the application has been registered.</span>
  <span class="c1">// It's possible to call app-&gt;register_application() explicitly, but</span>
  <span class="c1">// usually it's easier to let app-&gt;run() do it for you.</span>
  <span class="n">app</span><span class="o">-&gt;</span><span class="n">signal_activate</span><span class="p">().</span><span class="n">connect</span><span class="p">([]()</span> <span class="p">{</span> <span class="n">on_app_activate</span><span class="p">();</span> <span class="p">});</span>

  <span class="k">return</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Our program will start its execution at line 45. We create a <code class="language-plaintext highlighter-rouge">Gtk::Application</code>
with a proper <code class="language-plaintext highlighter-rouge">app-id</code> and then we connect the <code class="language-plaintext highlighter-rouge">activate</code> signal in line 51. Then
we run the application in line 53.</p>

<p>The activation signal is connected to the function <code class="language-plaintext highlighter-rouge">on_app_activate</code> at line 10.
One first thing it does is to ensure that our custom GObject class type is
registered. This class will be called <code class="language-plaintext highlighter-rouge">gtkmm__CustomObject_MyButton</code> inside the
GObject type system, and this is the name we used above in our XML file. As I
mentioned above, because glibmm combines class registration and object
instantiation in a single process, we need to create a dummy object (that will
be immediately destroyed) before Gtk.Builder instantiates an object of class
<code class="language-plaintext highlighter-rouge">gtkmm__CustomObject_MyButton</code>. If you remove line 15, line 20 will fail
because it will not be able to instantiate our custom GObject class.</p>

<p>The rest is more or less straightforward: we get the window instance from the
<code class="language-plaintext highlighter-rouge">.ui</code> file and we connect the <code class="language-plaintext highlighter-rouge">hide</code> signal so we destroy the window upon
returning. Recall that in the constructor of <code class="language-plaintext highlighter-rouge">DerivedWindow</code> we made our
button to hide the window, so it quits the application. We finally make
the window visible.</p>

<h2>Discussion</h2>

<p>This is the suggested approach in glibmm. I think its bigger advantage is that
it does not require a lot of additional machinery. However, due to the way
glibmm works internally, we need to remember to create a fake instance that
registers our class type in GObject. This requires a dummy default constructor
(which might be a problem when extending a class that does not have one) in
addition to the usual wrapping constructor used by Gtk::Builder. All the
constructors we want to have will have to be synchronised (though C++ can
mitigate this thanks to forwarding constructors and non-static data member
initialisers).</p>

<p>Let’s see if we can do something a bit more predictable. While the approach
used by glibmm is reasonable, registering a class type as a side effect of
creating an instance for me breaks the principle of least surprise.  In fact,
the ability of glibmm to hide the concept of the GObject class is so successful
that unless one starts reading glibmm’s code, it may be difficult to understand
how all the pieces fit. Leaving a user of the library with that “magic” feeling
that suddenly turns to unease when we cannot really explain how it all works.</p>

<h1>Manual approach</h1>

<p>Let’s follow a more manual approach, inspired by what <code class="language-plaintext highlighter-rouge">gmmproc</code> does. <code class="language-plaintext highlighter-rouge">gmmproc</code>
is the wrapping machinery that can be used to wrap GObject-based libraries. I will
do this with the <code class="language-plaintext highlighter-rouge">DerivedButton</code> class (though a similar approach can be used
with <code class="language-plaintext highlighter-rouge">DerivedWindow</code> if wanted).</p>

<p>One big downside of this approach is that we need some amount of boilerplate
(which <code class="language-plaintext highlighter-rouge">gmmproc</code> does for this when wrapping existing GObject-based libraries).</p>

<h2>Custom class helper</h2>

<p>We will have to define the GObject class class and the GObject instance class.
To define the class we will use a custom class that we will use to sidestep
some of the glibmm defaults.</p>

<figure class="highlight"><figcaption>customclass.h</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="cp">#ifndef GLIBMM_CUSTOMCLASS_H
#define GLIBMM_CUSTOMCLASS_H
</span>
<span class="cp">#include</span> <span class="cpf">&lt;glibmm/class.h&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">Glib</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">CustomClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Class</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Inherit constructors;</span>
  <span class="k">using</span> <span class="n">Class</span><span class="o">::</span><span class="n">Class</span><span class="p">;</span>

  <span class="c1">// Reintroduce existing overloads.</span>
  <span class="k">using</span> <span class="n">Class</span><span class="o">::</span><span class="n">register_derived_type</span><span class="p">;</span>
  <span class="c1">// Our new overload.</span>
  <span class="kt">void</span> <span class="n">register_derived_type</span><span class="p">(</span><span class="n">GType</span> <span class="n">base_type</span><span class="p">,</span>
                             <span class="n">GInstanceInitFunc</span> <span class="n">instance_init</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                             <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type_name</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span>
                             <span class="n">GTypeModule</span> <span class="o">*</span><span class="n">module</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace Glib</span>

<span class="cp">#endif // GLIBMM_CUSTOMCLASS_H</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The implementation class is a bit longer but basically repeats what
<code class="language-plaintext highlighter-rouge">Glib::Class</code> does but allowing us to specify a name.</p>

<figure class="highlight"><figcaption>customclass.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">"customclass.h"</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">Glib</span> <span class="p">{</span>

<span class="kt">void</span> <span class="n">CustomClass</span><span class="o">::</span><span class="n">register_derived_type</span><span class="p">(</span><span class="n">GType</span> <span class="n">base_type</span><span class="p">,</span>
                                        <span class="n">GInstanceInitFunc</span> <span class="n">instance_init</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type_name</span><span class="p">,</span>
                                        <span class="n">GTypeModule</span> <span class="o">*</span><span class="n">module</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gtype_</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span> <span class="c1">// already initialized</span>

  <span class="c1">// 0 is not a valid GType.</span>
  <span class="c1">// It would lead to a crash later.</span>
  <span class="c1">// We allow this, failing silently, to make life easier for gstreamermm.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">base_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span> <span class="c1">// already initialized</span>

<span class="cp">#if GLIB_CHECK_VERSION(2, 70, 0)
</span>  <span class="c1">// Don't derive a type if the base type is a final type.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">G_TYPE_IS_FINAL</span><span class="p">(</span><span class="n">base_type</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">gtype_</span> <span class="o">=</span> <span class="n">base_type</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
<span class="cp">#endif
</span>
  <span class="n">GTypeQuery</span> <span class="n">base_query</span> <span class="o">=</span> <span class="p">{</span>
      <span class="mi">0</span><span class="p">,</span>
      <span class="nb">nullptr</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span>
  <span class="p">};</span>
  <span class="n">g_type_query</span><span class="p">(</span><span class="n">base_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base_query</span><span class="p">);</span>

  <span class="c1">// GTypeQuery::class_size is guint but GTypeInfo::class_size is guint16.</span>
  <span class="k">const</span> <span class="n">guint16</span> <span class="n">class_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">guint16</span><span class="p">)</span><span class="n">base_query</span><span class="p">.</span><span class="n">class_size</span><span class="p">;</span>

  <span class="c1">// GTypeQuery::instance_size is guint but GTypeInfo::instance_size is</span>
  <span class="c1">// guint16.</span>
  <span class="k">const</span> <span class="n">guint16</span> <span class="n">instance_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">guint16</span><span class="p">)</span><span class="n">base_query</span><span class="p">.</span><span class="n">instance_size</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">GTypeInfo</span> <span class="n">derived_info</span> <span class="o">=</span> <span class="p">{</span>
      <span class="n">class_size</span><span class="p">,</span>
      <span class="nb">nullptr</span><span class="p">,</span>          <span class="c1">// base_init</span>
      <span class="nb">nullptr</span><span class="p">,</span>          <span class="c1">// base_finalize</span>
      <span class="n">class_init_func_</span><span class="p">,</span> <span class="c1">// Set by the caller ( *_Class::init() ).</span>
      <span class="nb">nullptr</span><span class="p">,</span>          <span class="c1">// class_finalize</span>
      <span class="nb">nullptr</span><span class="p">,</span>          <span class="c1">// class_data</span>
      <span class="n">instance_size</span><span class="p">,</span>
      <span class="mi">0</span><span class="p">,</span> <span class="c1">// n_preallocs</span>
      <span class="n">instance_init</span><span class="p">,</span>
      <span class="nb">nullptr</span><span class="p">,</span> <span class="c1">// value_table</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">base_query</span><span class="p">.</span><span class="n">type_name</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">g_critical</span><span class="p">(</span><span class="s">"Class::register_derived_type(): base_query.type_name is NULL."</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">gchar</span> <span class="o">*</span><span class="n">derived_name</span> <span class="o">=</span>
      <span class="p">(</span><span class="n">type_name</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">type_name</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
          <span class="o">?</span> <span class="n">g_strdup</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
          <span class="o">:</span> <span class="n">g_strconcat</span><span class="p">(</span><span class="s">"gtkmm__"</span><span class="p">,</span> <span class="n">base_query</span><span class="p">.</span><span class="n">type_name</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="n">gtype_</span> <span class="o">=</span> <span class="n">g_type_module_register_type</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">base_type</span><span class="p">,</span> <span class="n">derived_name</span><span class="p">,</span>
                                         <span class="o">&amp;</span><span class="n">derived_info</span><span class="p">,</span> <span class="n">GTypeFlags</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="k">else</span>
    <span class="n">gtype_</span> <span class="o">=</span> <span class="n">g_type_register_static</span><span class="p">(</span><span class="n">base_type</span><span class="p">,</span> <span class="n">derived_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">derived_info</span><span class="p">,</span>
                                    <span class="n">GTypeFlags</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

  <span class="n">g_free</span><span class="p">(</span><span class="n">derived_name</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace Glib</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2>Header</h2>

<p>With this first piece of boilerplate done, we can focus on manually deriving
our button.</p>

<figure class="highlight"><figcaption>derivedbutton.h</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="cp">#ifndef GTKMM_EXAMPLE_DERIVED_BUTTON_H
#define GTKMM_EXAMPLE_DERIVED_BUTTON_H
</span>
<span class="cp">#include</span> <span class="cpf">"customclass.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;gtkmm.h&gt;</span><span class="cp">
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
<span class="c1">// C types</span>
<span class="k">struct</span> <span class="nc">ExampleDerivedButton</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">ExampleDerivedButton_Class</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We will first define two opaque types as if they were the original C types for
our GObject. We will use those later.</p>

<p>We will first make a forward declaration to the C++ class that represents
the GObject class and then we can define the C++ class that represents
the GObject instances.</p>

<figure class="highlight"><figcaption>derivedbutton.h</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">DerivedButton_Class</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DerivedButton</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Button</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">DerivedButton</span><span class="p">(</span><span class="n">ExampleDerivedButton</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>
  <span class="n">DerivedButton</span><span class="p">(</span><span class="n">BaseObjectType</span> <span class="o">*</span><span class="n">cobject</span><span class="p">,</span> <span class="k">const</span> <span class="n">Glib</span><span class="o">::</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">DerivedButton</span><span class="p">();</span>

  <span class="k">static</span> <span class="n">GType</span> <span class="n">get_type</span><span class="p">();</span>
  <span class="k">static</span> <span class="n">GType</span> <span class="n">get_base_type</span><span class="p">();</span>

  <span class="n">ExampleDerivedButton</span> <span class="o">*</span><span class="n">gobj</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ExampleDerivedButton</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">gobject_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Glib</span><span class="o">::</span><span class="n">PropertyProxy</span><span class="o">&lt;</span><span class="n">Glib</span><span class="o">::</span><span class="n">ustring</span><span class="o">&gt;</span> <span class="n">property_ustring</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Glib</span><span class="o">::</span><span class="n">PropertyProxy</span><span class="o">&lt;</span><span class="n">Glib</span><span class="o">::</span><span class="n">ustring</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"button-ustring"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">Glib</span><span class="o">::</span><span class="n">PropertyProxy</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">property_int</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Glib</span><span class="o">::</span><span class="n">PropertyProxy</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"button-int"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">DerivedButton</span> <span class="o">*</span><span class="n">wrap</span><span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">take_copy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>

<span class="nl">private:</span>
  <span class="k">friend</span> <span class="n">DerivedButton_Class</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">DerivedButton_Class</span> <span class="n">derived_button_class</span><span class="p">;</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="n">instance_init_function</span><span class="p">(</span><span class="n">GTypeInstance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">g_class</span><span class="p">);</span>

  <span class="kt">void</span> <span class="n">on_ustring_changed</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">on_int_changed</span><span class="p">();</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="n">set_property</span><span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">guint</span> <span class="n">property_id</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">GValue</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">GParamSpec</span> <span class="o">*</span><span class="n">pspec</span><span class="p">);</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">get_property</span><span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">guint</span> <span class="n">property_id</span><span class="p">,</span> <span class="n">GValue</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
                           <span class="n">GParamSpec</span> <span class="o">*</span><span class="n">pspec</span><span class="p">);</span>

  <span class="n">Glib</span><span class="o">::</span><span class="n">ustring</span> <span class="n">button_ustring</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">button_int</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Now the class.</p>

<figure class="highlight"><figcaption>derivedbutton.h</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">DerivedButton_Class</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Glib</span><span class="o">::</span><span class="n">CustomClass</span> <span class="p">{</span>
<span class="nl">private:</span>
<span class="nl">public:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">DerivedButton</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Glib</span><span class="o">::</span><span class="n">Class</span> <span class="o">&amp;</span><span class="n">init</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">class_init_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">g_class</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">class_data</span><span class="p">);</span>

  <span class="k">static</span> <span class="n">Glib</span><span class="o">::</span><span class="n">ObjectBase</span> <span class="o">*</span><span class="n">wrap_new</span><span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">object</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#endif // GTKMM_EXAMPLE_DERIVED_BUTTON_H</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2><code class="language-plaintext highlighter-rouge">DerivedButton_Class</code> implementation</h2>

<p>There is a lot to unpack in the header above. I think, however that it is
easier to start from the class <code class="language-plaintext highlighter-rouge">DerivedButton_Class</code>. First note the static
data member <code class="language-plaintext highlighter-rouge">derived_button_class</code> in line 54 of <code class="language-plaintext highlighter-rouge">DerivedButton</code> class. This
will represent the GObject class and it will be used by <code class="language-plaintext highlighter-rouge">DerivedButton</code> to
register the type. This happens because we will obtain a reference of a
<code class="language-plaintext highlighter-rouge">Glib::Class</code> via the <code class="language-plaintext highlighter-rouge">DerivedButton_Class::init</code>.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">135
136
137
138
139
140
141
142
143
144
</pre></td><td class="code"><pre><span class="k">const</span> <span class="n">Glib</span><span class="o">::</span><span class="n">Class</span> <span class="o">&amp;</span><span class="n">DerivedButton_Class</span><span class="o">::</span><span class="n">init</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gtype_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">class_init_func_</span> <span class="o">=</span> <span class="n">DerivedButton_Class</span><span class="o">::</span><span class="n">class_init_function</span><span class="p">;</span>
    <span class="n">register_derived_type</span><span class="p">(</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">get_base_type</span><span class="p">(),</span>
                          <span class="n">DerivedButton</span><span class="o">::</span><span class="n">instance_init_function</span><span class="p">,</span> <span class="s">"MyButton"</span><span class="p">);</span>
    <span class="n">Glib</span><span class="o">::</span><span class="n">init</span><span class="p">();</span>
    <span class="n">Glib</span><span class="o">::</span><span class="n">wrap_register</span><span class="p">(</span><span class="n">gtype_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wrap_new</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">gtype_</code> is a data-member inherited from <code class="language-plaintext highlighter-rouge">Glib::Class</code>. If zero it means the
class needs registration, so we do this. We set
<code class="language-plaintext highlighter-rouge">DerivedButton_Class::class_init_function</code> as the class initialisation function
(field <code class="language-plaintext highlighter-rouge">class_init_func_</code> is also inherited and used in our
<code class="language-plaintext highlighter-rouge">CustomClass::register_derived_type</code> defined earlier). For simplicity of the
implementation, though this could be done better we invoke <code class="language-plaintext highlighter-rouge">Glib::init</code> that will
initialise all the internal machinery from <code class="language-plaintext highlighter-rouge">glibmm</code> and then we link this
new type with <code class="language-plaintext highlighter-rouge">DerivedButton_Class::wrap_new</code>. Recall that glibmm wraps
GObjects with a C++ object so it needs to link both, here we link this type
with the creation function. The creation function looks like this</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">146
147
148
</pre></td><td class="code"><pre><span class="n">Glib</span><span class="o">::</span><span class="n">ObjectBase</span> <span class="o">*</span><span class="n">DerivedButton_Class</span><span class="o">::</span><span class="n">wrap_new</span><span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">object</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">DerivedButton</span><span class="p">((</span><span class="n">ExampleDerivedButton</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Finally when an object of the class is instantiated for the first time
our class initialisation function (<code class="language-plaintext highlighter-rouge">DerivedButton_Class::class_init_function</code>) will
be invoked. It looks like this.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="n">DerivedButton_Class</span><span class="o">::</span><span class="n">class_init_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">g_class</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">class_data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">g_print</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">__PRETTY_FUNCTION__</span><span class="p">);</span>
  <span class="k">auto</span> <span class="o">*</span><span class="k">const</span> <span class="n">gobject_class</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">GObjectClass</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">g_class</span><span class="p">);</span>

  <span class="n">gobject_class</span><span class="o">-&gt;</span><span class="n">get_property</span> <span class="o">=</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">get_property</span><span class="p">;</span>
  <span class="n">gobject_class</span><span class="o">-&gt;</span><span class="n">set_property</span> <span class="o">=</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">set_property</span><span class="p">;</span>

  <span class="n">g_object_class_install_property</span><span class="p">(</span>
      <span class="n">gobject_class</span><span class="p">,</span> <span class="n">PROPERTY_INT</span><span class="p">,</span>
      <span class="n">g_param_spec_int</span><span class="p">(</span>
          <span class="s">"button-int"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="n">G_MININT</span><span class="p">,</span> <span class="n">G_MAXINT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
          <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">GParamFlags</span><span class="o">&gt;</span><span class="p">(</span><span class="n">G_PARAM_READWRITE</span> <span class="o">|</span> <span class="n">G_PARAM_CONSTRUCT</span><span class="p">)));</span>
  <span class="n">g_object_class_install_property</span><span class="p">(</span>
      <span class="n">gobject_class</span><span class="p">,</span> <span class="n">PROPERTY_STRING</span><span class="p">,</span>
      <span class="n">g_param_spec_string</span><span class="p">(</span>
          <span class="s">"button-ustring"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span>
          <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">GParamFlags</span><span class="o">&gt;</span><span class="p">(</span><span class="n">G_PARAM_READWRITE</span> <span class="o">|</span> <span class="n">G_PARAM_CONSTRUCT</span><span class="p">)));</span>

  <span class="k">const</span> <span class="k">auto</span> <span class="n">cpp_class</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Button_Class</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">g_class</span><span class="p">);</span>
  <span class="n">Gtk</span><span class="o">::</span><span class="n">Button_Class</span><span class="o">::</span><span class="n">class_init_function</span><span class="p">(</span><span class="n">cpp_class</span><span class="p">,</span> <span class="n">class_data</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>We basically install a couple of properties (using the C API, I don’t think we
can do much better here) and then we proceed to initialise the base class, in
our case <code class="language-plaintext highlighter-rouge">Gtk::Button</code>. <code class="language-plaintext highlighter-rouge">PROPERTY_INT</code> and <code class="language-plaintext highlighter-rouge">PROPERTY_STRING</code> are a couple of
enumerators that we use to identify these properties in this class.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">66
67
68
69
70
</pre></td><td class="code"><pre><span class="k">enum</span> <span class="n">PropertyId</span> <span class="p">{</span>
  <span class="n">INVALID_PROPERTY</span><span class="p">,</span>
  <span class="n">PROPERTY_INT</span><span class="p">,</span>
  <span class="n">PROPERTY_STRING</span><span class="p">,</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>This completes our implementation of the class. Note that we mention
a couple of functons in <code class="language-plaintext highlighter-rouge">DerivedButton</code> to access the properties that we
have just installed.</p>

<h2><code class="language-plaintext highlighter-rouge">DerivedButton</code> implementation</h2>

<p>I’m going to list here only the functions that have changes.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="n">DerivedButton</span><span class="o">::</span><span class="n">DerivedButton</span><span class="p">(</span><span class="n">BaseObjectType</span> <span class="o">*</span><span class="n">cobject</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Glib</span><span class="o">::</span><span class="n">RefPtr</span><span class="o">&lt;</span><span class="n">Gtk</span><span class="o">::</span><span class="n">Builder</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Button</span><span class="p">(</span><span class="n">cobject</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">property_ustring</span><span class="p">().</span><span class="n">signal_changed</span><span class="p">().</span><span class="n">connect</span><span class="p">(</span>
      <span class="n">sigc</span><span class="o">::</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">on_ustring_changed</span><span class="p">));</span>
  <span class="n">property_int</span><span class="p">().</span><span class="n">signal_changed</span><span class="p">().</span><span class="n">connect</span><span class="p">(</span>
      <span class="n">sigc</span><span class="o">::</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">on_int_changed</span><span class="p">));</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>The constructor that can be invoked by the builder is almost the same,
it does not have to invoke the constructor of <code class="language-plaintext highlighter-rouge">ObjectBase</code> in any special way.</p>

<p>Ideally we would use this constructor, but it turns out that we may build
the wrapping C++ object earlier. So let’s add one constructor for this case.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="n">DerivedButton</span><span class="o">::</span><span class="n">DerivedButton</span><span class="p">(</span><span class="n">ExampleDerivedButton</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Gtk</span><span class="o">::</span><span class="n">Button</span><span class="p">((</span><span class="n">GtkButton</span> <span class="o">*</span><span class="p">)</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">property_ustring</span><span class="p">().</span><span class="n">signal_changed</span><span class="p">().</span><span class="n">connect</span><span class="p">(</span>
      <span class="n">sigc</span><span class="o">::</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">on_ustring_changed</span><span class="p">));</span>
  <span class="n">property_int</span><span class="p">().</span><span class="n">signal_changed</span><span class="p">().</span><span class="n">connect</span><span class="p">(</span>
      <span class="n">sigc</span><span class="o">::</span><span class="n">mem_fun</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">on_int_changed</span><span class="p">));</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Needless to say that, even if I did not do here, we can factor out the body of
the constructor.</p>

<p>One of the functions that GObject requires is an instance initialisation function
but ours does not have to do anything special because we will keep the state
in the C++ object and not in the GObject itself.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">51
52
53
54
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">instance_init_function</span><span class="p">(</span><span class="n">GTypeInstance</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span>
                                           <span class="kt">void</span> <span class="o">*</span> <span class="cm">/* g_class */</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Does nothing.</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There are two functions used when registering the GObject class in
<code class="language-plaintext highlighter-rouge">DerivedButton_Class</code>. Those return <code class="language-plaintext highlighter-rouge">GType</code>s which is the way GObject uses to
identify types (they are just integer handles). We need one for the current class
(<code class="language-plaintext highlighter-rouge">MyButton</code>) and one for the base (<code class="language-plaintext highlighter-rouge">GtkButton</code>).</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">56
57
58
59
60
</pre></td><td class="code"><pre><span class="n">GType</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">get_type</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">derived_button_class</span><span class="p">.</span><span class="n">init</span><span class="p">().</span><span class="n">get_type</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">GType</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">get_base_type</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GTK_TYPE_BUTTON</span><span class="p">;</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>When requesting the curerent type, this will register the type using
the <code class="language-plaintext highlighter-rouge">init</code> member function of <code class="language-plaintext highlighter-rouge">DerivedButton_Class</code>.</p>

<p>Finally we need a function that knows how to wrap a C GObject representing our
class (not the C++ one) into a C++ object, creating one if needed. This is done
using <code class="language-plaintext highlighter-rouge">Glib::wrap_auto</code>. This function will invoke, if there is no C++ wrapper
object for the GObject, the function <code class="language-plaintext highlighter-rouge">DerivedButton_Class::wrap_new</code> shown
earlier and that we registered in glibmm when registering the new GObject class
type.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">62
63
64
</pre></td><td class="code"><pre><span class="n">DerivedButton</span> <span class="o">*</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">wrap</span><span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">take_copy</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">DerivedButton</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">Glib</span><span class="o">::</span><span class="n">wrap_auto</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">take_copy</span><span class="p">));</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>I mentioned earlier that we need a couple of functions to access the properties.
We still need to implement them. Those functions are basically C interfaces
but we can still use most of the time the glibmm wrappers.</p>

<figure class="highlight"><figcaption>derivedbutton.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">set_property</span><span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">guint</span> <span class="n">property_id</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">GValue</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">GParamSpec</span> <span class="o">*</span><span class="n">pspec</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DerivedButton</span> <span class="o">*</span><span class="n">this_</span> <span class="o">=</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">wrap</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
  <span class="n">g_assert</span><span class="p">(</span><span class="n">this_</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">property_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">PROPERTY_INT</span><span class="p">:</span> <span class="p">{</span>
    <span class="n">Glib</span><span class="o">::</span><span class="n">Value</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_val</span> <span class="o">!=</span> <span class="n">this_</span><span class="o">-&gt;</span><span class="n">button_int</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">this_</span><span class="o">-&gt;</span><span class="n">button_int</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
      <span class="n">g_object_notify_by_pspec</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">pspec</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">PROPERTY_STRING</span><span class="p">:</span> <span class="p">{</span>
    <span class="n">Glib</span><span class="o">::</span><span class="n">Value</span><span class="o">&lt;</span><span class="n">Glib</span><span class="o">::</span><span class="n">ustring</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">Glib</span><span class="o">::</span><span class="n">ustring</span> <span class="n">new_val</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_val</span> <span class="o">!=</span> <span class="n">this_</span><span class="o">-&gt;</span><span class="n">button_ustring</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">this_</span><span class="o">-&gt;</span><span class="n">button_ustring</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
      <span class="n">g_object_notify_by_pspec</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">pspec</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nl">default:</span> <span class="p">{</span>
    <span class="n">G_OBJECT_WARN_INVALID_PROPERTY_ID</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">property_id</span><span class="p">,</span> <span class="n">pspec</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">get_property</span><span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="n">guint</span> <span class="n">property_id</span><span class="p">,</span>
                                 <span class="n">GValue</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">GParamSpec</span> <span class="o">*</span><span class="n">pspec</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DerivedButton</span> <span class="o">*</span><span class="n">this_</span> <span class="o">=</span> <span class="n">DerivedButton</span><span class="o">::</span><span class="n">wrap</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
  <span class="n">g_assert</span><span class="p">(</span><span class="n">this_</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">property_id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">PROPERTY_INT</span><span class="p">:</span> <span class="p">{</span>
    <span class="n">Glib</span><span class="o">::</span><span class="n">Value</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">value_type</span><span class="p">());</span>
    <span class="n">v</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">this_</span><span class="o">-&gt;</span><span class="n">button_int</span><span class="p">);</span>
    <span class="n">g_value_copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">gobj</span><span class="p">(),</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">PROPERTY_STRING</span><span class="p">:</span> <span class="p">{</span>
    <span class="n">Glib</span><span class="o">::</span><span class="n">Value</span><span class="o">&lt;</span><span class="n">Glib</span><span class="o">::</span><span class="n">ustring</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">value_type</span><span class="p">());</span>
    <span class="n">v</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">this_</span><span class="o">-&gt;</span><span class="n">button_ustring</span><span class="p">);</span>
    <span class="n">g_value_copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">gobj</span><span class="p">(),</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nl">default:</span> <span class="p">{</span>
    <span class="n">G_OBJECT_WARN_INVALID_PROPERTY_ID</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">property_id</span><span class="p">,</span> <span class="n">pspec</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>There is an interesting trivia fact here, is that <code class="language-plaintext highlighter-rouge">Glib::Property&lt;T&gt;</code> as provided
by glibmm installs the properties when creating of the object wrapper while
we have installed them when creating the class.</p>

<p>Another difference, is that glibmm’s generic function to get and set properties
will always notify about changes even if the property is set to the previous
value it held. We show a simple way to implement a more precise mechanism here.</p>

<p>Another interesting fact that happens here, is that the call to
<code class="language-plaintext highlighter-rouge">DerivedButton::wrap</code> happens while initialising the GObject via <code class="language-plaintext highlighter-rouge">Gtk.Builder</code>,
this means that we will invoke the new constructor we added and that the
previous one we had, will not be invoked because when the <code class="language-plaintext highlighter-rouge">DerivedWindow</code> class
tries to obtain the derived button, the wrapper object will exist already, so
the constructor we had will not actually run.</p>

<h2>Registering the type</h2>

<p>Finally we need to make sure the type exists. We do that by registering it at
the beginning of the application, in the same place were before we had to
create a dummy instance instead.</p>

<figure class="highlight"><figcaption>main.cc</figcaption><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">28
29
30
31
32
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="nf">on_app_activate</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Make sure the type has been registered.</span>
  <span class="n">g_type_ensure</span><span class="p">(</span><span class="n">DerivedButton</span><span class="o">::</span><span class="n">get_type</span><span class="p">());</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h2>Discussion</h2>

<p>When writing the wrapper manually, we need a moderate amount of boilerplate.
In defense of gtkmm, though, the boilerplate is more or less at the level of
what one usually needs when implementing GObjects in C. Also a few things
cannot be done in C++ (because glibmm does not wrap much on the side of the
classes) so we end invoking C interfaces.</p>

<p>One interesting thing we have not addressed are signals, unfortunately signals
require the creation of a function that marshalls correctly the parameters. I
think some C++ template pixie dust can help here, but the function must exist.
Adding new signals is, thus, not trivial.</p>

<p>Finally, one thing that may not be obvious, is that the GObject will always
entail the existence of a C++ wrapper. This is a fundamental aspect of glibmm,
so while we can implement a full-fledged GObject, it will always require its
C++ counterpart around.</p>

<h1>Conclusion</h1>

<p>Given the seamless integration between C and C++, it is relatively
straightforward to fully write a new GObject using C++. The recommended
approach in the gtkmm documentation has the downside it requires a default
constructor (imposing this requirement to the base class) and creating
a dummy object that will cause the registration of the new GObject class.</p>

<p>When written manually, the amount of boilerplace is significant and given that
glibmm does not wrap much the C API for classes itself, we find ourselves forced
to use GObject C interfaces.</p>

<p>All in all, I believe the recommended approach is more reasonable as long as
we understand the nuance with the registration of the derived GObject class.</p>

  </div>

</article>

<div class="pagination">

  <a class="previous" href="/2023/01/15/wrapping-gobjects-in-cpp/">&laquo; Wrapping GObjects in C++</a>


  <a class="next" href="/2023/09/03/remote-notifications-over-ssh/">Graphical notifications for long-running tasks &raquo;</a>

</div>



      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

Powered by <a href="https://jekyllrb.com">Jekyll</a>. Theme based on <a href="https://github.com/yous/whiteglass">whiteglass</a>
<br>
Subscribe via <a href="https://thinkingeek.com/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
